# Main R Script for Cancer Multi-Omics Data Analysis

# --- 0. Setup and Configuration ---
message("--- Script Started ---")

# --- Install and Load Libraries ---
# 1. Load Bioconductor packages FIRST
library(minfi) # For methylation array data processing
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19) # EPIC array annotation
library(biomaRt) # For gene symbol mapping via Ensembl
library(limma) # For differential expression analysis (explicitly load)

# 2. Load other specialized packages (non-Bioconductor, non-tidyverse core)
library(mclust) # For Gaussian Mixture Models (not directly used for new clustering but was in original context)
library(ggpubr) # Required for stat_compare_means in plots
library(cowplot) # For plot_grid
library(rlang)    # For tidy evaluation
library(readxl)   # For reading Excel files
library(caret)    # For machine learning training workflow
library(glmnet)   # For Elastic Net models
library(doParallel) # For parallel processing
library(tibble)   # For tibble operations
library(cluster)      # For silhouette analysis
library(factoextra) # For fviz_nbclust (for optimal k determination)

# 3. Load Tidyverse packages (dplyr, tidyr, ggplot2, stringr, purrr, readr, broom) LAST.
library(dplyr)    # For data manipulation
library(tidyr)    # For data tidying
library(stringr) # For string manipulation
library(purrr)    # For functional programming
library(readr)    # For fast data import
library(ggplot2) # For data visualization
library(broom)    # For tidying model outputs
# Make sure to install and load the 'digest' package for unique hashing
# install.packages("digest") # if you don't have it
library(digest)


# --- End of Recommended Package Loading Order ---

# --- Configuration and File Paths ---
# Set your base directory where input data files are located
base_dir <- "D:/Laboratorio/Pediatrico/CCMA primary multi-omics datasets/ccma datasets/"

# Define an output directory for results and plots
output_dir <- "D:/Laboratorio/Pediatrico/CCMA primary multi-omics datasets/ccma datasets/20250609_METILACION/20250909_output_analysis"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  message(paste0("Created output directory: ", output_dir))
}
message(paste0("Output directory set to: ", output_dir))

# --- Global Variables for Analysis ---
target_gene_symbol <- "MGMT" # This is now just a placeholder for annotation loading.

# Specific pediatric cancer subtypes of interest for filtering and plotting.
pediatric_glioma_subtypes_of_interest <- c(
  "Adult High Grade Glioma",
  "H3-wildtype High-Grade Glioma",
  "H3K27-mutant Diffuse Midline Glioma",
  "H3G34-mutant Diffuse Hemispheric Glioma"
)

# Define criteria for initial probe filtering (pre-correlation) - still used for annotation loading
target_refgene_groups <- c("TSS1500", "TSS200", "5'UTR", "1stExon", "Body")
target_relation_to_island <- "Island"

# Define number of top CpGs for clustering (adjust as needed)
top_n_cpgs_for_clustering <- 5000 # Example: use top 5000 highly variable CpGs for clustering

# Store methylation probe annotations for later use
message("Loading methylation probe annotations...")
# The annotation object is usually named after the package, e.g., 'IlluminaHumanMethylationEPICanno.ilm10b4.hg19'
# We need to access the data from it. The 'map' function in minfi can help get the relevant table.
# Or, more directly, get the annotation data frame:
epic_anno <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("probe") # Convert row names (probe IDs) to a column
message(paste0("Loaded annotations for ", nrow(epic_anno), " EPIC array probes."))


# Setup parallel processing for caret models
num_cores <- detectCores() - 1 # Use all but one core
if (num_cores < 1) num_cores <- 1
message(paste0("Registering parallel backend with ", num_cores, " cores."))
cl <- makeCluster(num_cores)
registerDoParallel(cl)

######################################################
########## Section 1: Load and Prepare Data ##########
######################################################

# --- 1. Load and Prepare Data ---
message("\n--- Section 1: Loading and Preparing Data ---")

# --- 1.1 Clinical Data ---
message("Loading Clinical Data...")
sample_info_path <- file.path(base_dir, "openpbta/openpbta/CCMA_sampleinfo_042024.xlsx")
if (!file.exists(sample_info_path)) {
  stop(paste0("Error: Clinical data file not found at:\n", sample_info_path))
}
clinical_data <- read_excel(sample_info_path) %>%
  dplyr::select(sample, cancer_type_fullname) %>%
  dplyr::mutate(sample = as.character(sample))

if (any(duplicated(clinical_data$sample))) {
  warning("Duplicate sample IDs found in clinical_data. Using unique samples.")
  clinical_data <- clinical_data %>% distinct(sample, .keep_all = TRUE)
}
message(paste0("Loaded ", nrow(clinical_data), " samples from clinical_data.xlsx"))


# --- 1.2 RNA-seq Data ---
message("Loading RNA-seq Data...")
rnaseq_file_path <- file.path(base_dir, "CCMA_rnaseq_logcpm1_042024.csv")
if (!file.exists(rnaseq_file_path)) {
  stop(paste0("Error: RNA-seq data file not found at:\n", rnaseq_file_path))
}
rnaseq_data_wide_raw <- read_csv(rnaseq_file_path, show_col_types = FALSE)
message("RNA-seq data loaded in wide format (genes as rows, samples as columns).")

# Keeping rnaseq_data in long format here, as it's needed for later gene-specific operations.
# The memory issue from merging will be addressed in Section 3 by not merging the full long RNA-seq data directly.
rnaseq_data <- rnaseq_data_wide_raw %>%
  tidyr::pivot_longer(
    cols = -(geneid:length),
    names_to = "sample",
    values_to = "expression_value"
  ) %>%
  dplyr::select(sample, geneid, gene, chr, length, expression_value) %>%
  dplyr::mutate(sample = as.character(sample), geneid = as.character(geneid))
message("RNA-seq data reshaped to long format (each row is a sample-gene-expression triplet).")
rm(rnaseq_data_wide_raw)
gc()

# --- 1.3 Methylation Data ---
message("Loading Methylation Data (full genome-wide for clustering)...")
methylation_data_path_file <- file.path(base_dir, "CCMA_methyl_betascores_042024.csv")
if (!file.exists(methylation_data_path_file)) {
  stop(paste0("Error: Methylation data file not found at:\n", methylation_data_path_file))
}

# Load the full wide methylation data (probes as rows, samples as columns)
methylation_data_wide_probes_as_rows_full <- read_csv(methylation_data_path_file, show_col_types = FALSE)
message("Full methylation data loaded (probes as rows, samples as columns).")

# FIX: Handle duplicate probe IDs by keeping only distinct (assuming they are identical duplicates)
# If duplicates have differing values, a median/mean aggregation would be better (as discussed previously).
# For now, sticking to the `distinct` as in the previous example to avoid further errors.
if (any(duplicated(methylation_data_wide_probes_as_rows_full$probe))) {
  warning("Duplicate probe IDs found in methylation data. Keeping only distinct probe entries.")
  methylation_data_wide_probes_as_rows_full <- methylation_data_wide_probes_as_rows_full %>%
    dplyr::distinct(probe, .keep_all = TRUE)
}


# Convert to samples as rows, probes as columns for easy use in clustering/prediction
# This is `methylation_data_wide` to be used by new Section 2 and old Section 8.5
methylation_data_wide <- methylation_data_wide_probes_as_rows_full %>%
  tibble::column_to_rownames("probe") %>%
  t() %>% # Transpose to samples as rows, probes as columns
  as.data.frame() %>%
  tibble::rownames_to_column("sample") %>%
  dplyr::mutate(sample = as.character(sample))

# Ensure all columns are numeric, excluding 'sample'
methylation_data_wide <- methylation_data_wide %>%
  dplyr::mutate(across(where(is.character) & !starts_with("sample"), as.numeric))

message(paste0("Methylation data pivoted to wide format (samples as rows, CpGs as columns) for ",
               nrow(methylation_data_wide), " samples and ", ncol(methylation_data_wide) - 1, " CpGs."))
rm(methylation_data_wide_probes_as_rows_full)
gc()


# --- 1.4 Drug Sensitivity Data ---
message("Loading Drug Sensitivity Data...")
drug_screening_file_path <- file.path(base_dir, "20250610_CCMA_drugscreen_zscores_pivoted_042024.csv")
if (!file.exists(drug_screening_file_path)) {
  stop(paste0("Error: Drug screening data file not found at:\n", drug_screening_file_path))
}
drug_data_raw <- read_csv(drug_screening_file_path, show_col_types = FALSE)

print(head(drug_data_raw))

# Add 'drug_' prefix to drug columns
drug_value_cols <- setdiff(colnames(drug_data_raw), "sample")
if (length(drug_value_cols) == 0) {
  stop("Error: 'drug_data_raw' contains no drug columns beyond 'sample'. Please check its content.")
}
drug_data_wide <- drug_data_raw %>%
  dplyr::rename_with(~ paste0("drug_", .), .cols = all_of(drug_value_cols)) %>%
  dplyr::mutate(sample = as.character(sample)) %>%
  tibble::column_to_rownames("sample")

message(paste0("Loaded Drug Sensitivity data for ", nrow(drug_data_wide), " samples and ", ncol(drug_data_wide), " drugs (wide format)."))
rm(drug_data_raw)
gc()

# --- 1.5 Gene Symbol Map (from BiomaRt) ---
message("\n--- Loading/Generating Gene Symbol Map ---")
output_gene_map_path <- file.path(base_dir, "gene_symbol_map.csv")
if (!file.exists(output_gene_map_path)) {
  message("Generating gene_symbol_map.csv using BiomaRt...")
  tryCatch({
    ensembl_mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
    gene_map <- getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'description'), mart = ensembl_mart)
    gene_symbol_map_df <- gene_map %>%
      dplyr::rename(geneid = ensembl_gene_id, gene = hgnc_symbol) %>%
      dplyr::filter(gene != "") %>%
      dplyr::distinct(geneid, .keep_all = TRUE)
    write_csv(gene_symbol_map_df, file = output_gene_map_path)
    message(paste0("Successfully created 'gene_symbol_map.csv' at:\n", output_gene_map_path))
  }, error = function(e) {
    message(paste0("Error generating gene_symbol_map.csv: ", e$message))
    stop("Failed to generate gene_symbol_map.csv. Please fix the BiomaRt connection issue.")
  })
} else {
  message(paste0("Skipping BiomaRt gene map generation. 'gene_symbol_map.csv' already exists at:\n", output_gene_map_path))
  gene_symbol_map_df <- read_csv(output_gene_map_path, show_col_types = FALSE)
}


################################################################################
########## Section 2: DNA Methylation Profile Classification (Clustering) ######
################################################################################

message("\n--- Section 2: DNA Methylation Profile Classification (Clustering) ---")

# Create a subdirectory for clustering plots
clustering_output_dir <- file.path(output_dir, "Methylation_Clustering_Plots")
if (!dir.exists(clustering_output_dir)) {
  dir.create(clustering_output_dir, recursive = TRUE)
  message(paste0("Created clustering plots directory: ", clustering_output_dir))
}

# Get unique cancer types from your metadata
unique_cancer_types <- unique(clinical_data$cancer_type_fullname)

# Create an empty list to store clustering results for each cancer type
all_cancer_type_clusters <- list()

# Loop through each unique cancer type
for (current_cancer_type in unique_cancer_types) {
  
  # NEW: Only perform clustering for specified pediatric glioma subtypes
  if (!current_cancer_type %in% pediatric_glioma_subtypes_of_interest) {
    message(paste0("Skipping clustering for '", current_cancer_type, "' (not in pediatric_glioma_subtypes_of_interest list)."))
    next # Skip to the next cancer type
  }
  
  message(paste0("\nPerforming clustering for: ", current_cancer_type))
  
  # 2.1 Prepare Data for Clustering (Per Cancer Type)
  # Filter methylation data for the current cancer type
  samples_in_current_type <- clinical_data %>%
    dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
    dplyr::pull(sample)
  
  # Ensure that samples_in_current_type matches row names of methylation_data_wide
  # Also, select only the samples relevant to the current cancer type
  methylation_wide_for_clustering_raw_current_type <- methylation_data_wide %>%
    dplyr::filter(sample %in% samples_in_current_type) %>%
    tibble::column_to_rownames("sample")
  
  # Remove columns (probes) with any NA values for clustering within this subtype
  methylation_wide_for_clustering_current_type <-
    methylation_wide_for_clustering_raw_current_type[
      , colSums(is.na(methylation_wide_for_clustering_raw_current_type)) == 0
    ]
  
  # Check if there are enough samples/probes to cluster for this cancer type
  if (nrow(methylation_wide_for_clustering_current_type) < 4 || ncol(methylation_wide_for_clustering_current_type) < 2) {
    message(paste0("Skipping ", current_cancer_type, " due to insufficient data for clustering (less than 4 samples or 2 probes without NAs)."))
    next # Skip to the next cancer type
  }
  
  # 2.2 Feature Selection (Top N MAD CpGs for the current cancer type)
  # Calculate Median Absolute Deviation (MAD) for each CpG site
  methylation_mad_for_clustering_current_type <-
    apply(methylation_wide_for_clustering_current_type, 2, mad, na.rm = TRUE)
  
  # Select the top N CpGs with the highest MAD for clustering
  top_n_actual <- min(top_n_cpgs_for_clustering, length(methylation_mad_for_clustering_current_type))
  selected_cpgs_for_clustering_current_type <-
    names(sort(methylation_mad_for_clustering_current_type, decreasing = TRUE))[1:top_n_actual]
  
  methylation_for_clustering_current_type <-
    methylation_wide_for_clustering_current_type %>%
    dplyr::select(all_of(selected_cpgs_for_clustering_current_type))
  
  message(paste0("  Selected ", ncol(methylation_for_clustering_current_type), " highly variable CpGs for clustering in ", current_cancer_type, "."))
  
  # 2.3 Hierarchical Clustering (Per Cancer Type)
  dist_matrix_current_type <- dist(methylation_for_clustering_current_type, method = "euclidean")
  hclust_result_current_type <- hclust(dist_matrix_current_type, method = "ward.D2")
  
  # 2.4 Determine Number of Clusters and Assign Labels
  # Dynamically determine k using silhouette method
  # Test a range of k values, considering minimum group size
  max_k_possible <- min(5, floor(nrow(methylation_for_clustering_current_type) / 2)) # Max 5 groups, but at least 2 samples per group
  if (max_k_possible < 2) { # Ensure at least 2 clusters is considered if possible
    message(paste0("  Skipping clustering for ", current_cancer_type, ": Not enough samples to reasonably determine more than 1 cluster."))
    next
  }
  
  # Use fviz_nbclust with 'hcut' for hierarchical clustering
  # Set a reasonable min_k
  min_k_val <- 2
  if (nrow(methylation_for_clustering_current_type) < 6) { # If few samples, only try 2 groups.
    min_k_val <- 2
    max_k_possible <- min(max_k_possible, 2)
  }
  
  message(paste0("  Evaluating optimal number of clusters (k) from ", min_k_val, " to ", max_k_possible, " for ", current_cancer_type, "..."))
  nb <- NULL
  tryCatch({
    nb <- fviz_nbclust(methylation_for_clustering_current_type, FUN = hcut, method = "silhouette",
                       k.max = max_k_possible, nboot = 50, # Reduced nboot for speed, increase for robustness
                       diss = dist_matrix_current_type, hc_method = "ward.D2",
                       verbose = FALSE) # Suppress detailed messages
  }, error = function(e) {
    message(paste0("  Warning: fviz_nbclust failed for ", current_cancer_type, ": ", e$message, ". Defaulting to k=2."))
  })
  
  k_clusters_current_type <- 2 # Default to 2 groups if auto-detection fails or is not applicable
  # --- START MODIFIED PART TO EXTRACT OPTIMAL K ---
  if (!is.null(nb) && !is.null(nb$data)) { # Ensure nb is not null AND has a 'data' component
    # Ensure 'cluster' and 'y' columns are present and numeric if expected
    if ("cluster" %in% colnames(nb$data) && "y" %in% colnames(nb$data)) {
      optimal_k_df <- nb$data %>%
        dplyr::filter(!is.na(y)) %>% # Remove any NA silhouette scores
        dplyr::arrange(dplyr::desc(y)) %>% # Arrange by silhouette score in descending order
        head(1) # Get the first row (highest silhouette score)
      
      if (nrow(optimal_k_df) > 0) {
        k_clusters_current_type <- as.numeric(optimal_k_df$cluster[1])
        if (k_clusters_current_type < min_k_val) { # Ensure k is at least min_k_val
          k_clusters_current_type <- min_k_val
        }
      }
    } else {
      message(paste0("  Warning: 'cluster' or 'y' column not found in fviz_nbclust result for ", current_cancer_type, ". Defaulting to k=2."))
    }
  } else {
    message(paste0("  Warning: fviz_nbclust result 'nb' or 'nb$data' is NULL for ", current_cancer_type, ". Defaulting to k=2."))
  }
  # --- END MODIFIED PART ---
  
  message(paste0("  Optimal number of clusters for ", current_cancer_type, " determined as: ", k_clusters_current_type))
  
  # Cut the dendrogram into the determined number of clusters
  clusters_current_type <- cutree(hclust_result_current_type, k = k_clusters_current_type)
  
  # Plot and save dendrogram and silhouette plot
  plot_filename_prefix <- gsub("[^A-Za-z0-9_]", "_", current_cancer_type)
  dendro_path <- file.path(clustering_output_dir, paste0(plot_filename_prefix, "_Dendrogram.png"))
  png(dendro_path, width = 1200, height = 800, res = 100)
  plot(hclust_result_current_type, main = paste0("Dendrogram for ", current_cancer_type, " (k=", k_clusters_current_type, ")"),
       xlab = "Samples", ylab = "Height", sub = "")
  rect.hclust(hclust_result_current_type, k = k_clusters_current_type, border = 2:k_clusters_current_type)
  dev.off()
  message(paste0("  Dendrogram saved to: ", dendro_path))
  
  if (!is.null(nb)) {
    silhouette_plot_path <- file.path(clustering_output_dir, paste0(plot_filename_prefix, "_Silhouette_Plot.png"))
    png(silhouette_plot_path, width = 1000, height = 700, res = 100)
    print(nb) # Print the fviz_nbclust plot
    dev.off()
    message(paste0("  Silhouette plot saved to: ", silhouette_plot_path))
  }
  
  
  # 2.5 Assign Cluster Labels
  cluster_df_current_type <- data.frame(
    sample = names(clusters_current_type),
    Methylation_Profile_Group = paste0(current_cancer_type, "_Group_", clusters_current_type)
  )
  
  # Store the results
  all_cancer_type_clusters[[current_cancer_type]] <- cluster_df_current_type
}

# Combine all cluster results into a single dataframe
final_methylation_subtypes <- dplyr::bind_rows(all_cancer_type_clusters)
message(paste0("\nMethylation subtypes determined for ", length(unique(final_methylation_subtypes$sample)), " samples across selected cancer types."))

# Merge back into clinical_data, creating the comprehensive clinical_data_merged object
# This object will be used in subsequent sections for filtering and analysis
clinical_data_merged <- clinical_data %>%
  dplyr::left_join(final_methylation_subtypes, by = "sample") %>%
  # Ensure samples not assigned to a cluster (e.g., from skipped cancer types) get "Not_Clustered"
  dplyr::mutate(Methylation_Profile_Group = ifelse(is.na(Methylation_Profile_Group), "Not_Clustered", Methylation_Profile_Group))

message(paste0("Updated clinical_data_merged created with methylation profile groups for ", nrow(clinical_data_merged), " samples."))

# Save the clustering results to .CSV
clustering_results_path <- file.path(output_dir, "methylation_clustering_results.csv")
write_csv(clinical_data_merged, clustering_results_path)
message(paste0("Methylation clustering results (clinical_data_merged) saved to: ", clustering_results_path))

# 2.6 Rename Methylation Profile Groups based on average beta values ---
message("\n--- 2.6: Renaming Methylation Profile Groups ---")

# We need the methylation_for_clustering_current_type for each cancer type
# to determine which group is "methylated" and which is "unmethylated".
# This requires re-doing the loop or storing methylation_for_clustering_current_type
# which might be memory intensive.

# A more practical approach:
# Loop through the cancer types that were actually clustered
clustered_cancer_types <- final_methylation_subtypes %>%
  dplyr::distinct(cancer_type_fullname = gsub("_Group_.*", "", Methylation_Profile_Group)) %>%
  dplyr::pull(cancer_type_fullname)

# Initialize a list to hold the renamed clinical data for merging
renamed_clinical_data_parts <- list()

for (current_cancer_type in clustered_cancer_types) {
  message(paste0("  Determining 'Methylated'/'Unmethylated' labels for: ", current_cancer_type))
  
  # 1. Get samples and their original cluster labels for this cancer type
  samples_current_type_with_groups <- clinical_data_merged %>%
    dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
    dplyr::select(sample, Methylation_Profile_Group) %>%
    dplyr::filter(Methylation_Profile_Group != "Not_Clustered") # Only clustered samples
  
  # If only one group was found (e.g., k=1 or all samples fell into one group due to filtering), skip
  if (length(unique(samples_current_type_with_groups$Methylation_Profile_Group)) < 2) {
    message(paste0("    Only one methylation group found for ", current_cancer_type, ". Skipping specific Methylated/Unmethylated renaming."))
    renamed_clinical_data_parts[[current_cancer_type]] <- samples_current_type_with_groups %>%
      dplyr::mutate(Methylation_Profile_Group_Renamed = Methylation_Profile_Group) # Keep original name
    next
  }
  
  # 2. Re-select the top CpGs for this specific cancer type
  # This part is slightly redundant but necessary to get the *exact* CpGs used
  # during the clustering run if you didn't save them.
  # If memory is an issue, consider saving these lists of CpGs during the main clustering loop.
  samples_in_current_type_for_cpg_selection <- clinical_data %>%
    dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
    dplyr::pull(sample)
  
  methylation_wide_for_clustering_raw_current_type_for_rename <- methylation_data_wide %>%
    dplyr::filter(sample %in% samples_in_current_type_for_cpg_selection) %>%
    tibble::column_to_rownames("sample")
  
  methylation_wide_for_clustering_current_type_for_rename <-
    methylation_wide_for_clustering_raw_current_type_for_rename[
      , colSums(is.na(methylation_wide_for_clustering_raw_current_type_for_rename)) == 0
    ]
  
  methylation_mad_for_clustering_current_type_for_rename <-
    apply(methylation_wide_for_clustering_current_type_for_rename, 2, mad, na.rm = TRUE)
  
  top_n_actual_for_rename <- min(top_n_cpgs_for_clustering, length(methylation_mad_for_clustering_current_type_for_rename))
  selected_cpgs_for_clustering_current_type_for_rename <-
    names(sort(methylation_mad_for_clustering_current_type_for_rename, decreasing = TRUE))[1:top_n_actual_for_rename]
  
  # Filter methylation_data_wide to only these samples and selected CpGs
  methylation_data_filtered_for_rename <- methylation_data_wide %>%
    dplyr::filter(sample %in% samples_current_type_with_groups$sample) %>%
    dplyr::select(sample, all_of(selected_cpgs_for_clustering_current_type_for_rename)) %>%
    tibble::column_to_rownames("sample")
  
  
  # 3. Calculate average beta value for each group across the selected CpGs
  group_avg_betas <- samples_current_type_with_groups %>%
    dplyr::left_join(methylation_data_filtered_for_rename %>% tibble::rownames_to_column("sample"), by = "sample") %>%
    dplyr::group_by(Methylation_Profile_Group) %>%
    dplyr::summarise(
      average_beta = mean(c_across(all_of(selected_cpgs_for_clustering_current_type_for_rename)), na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    dplyr::arrange(average_beta) # Order by average beta value
  
  # Determine which group is "unmethylated" and which is "methylated"
  # Assuming the group with lower average beta is "Unmethylated"
  unmethylated_group_name <- group_avg_betas$Methylation_Profile_Group[1]
  methylated_group_name <- group_avg_betas$Methylation_Profile_Group[2]
  
  # Create a mapping for renaming
  renaming_map <- c(
    "Unmethylated" = unmethylated_group_name,
    "Methylated" = methylated_group_name
  )
  names(renaming_map) <- c(
    paste0(current_cancer_type, "_Unmethylated"),
    paste0(current_cancer_type, "_Methylated")
  )
  # Invert the map for dplyr::recode
  inverse_renaming_map <- setNames(names(renaming_map), unname(renaming_map))
  
  
  # Apply the renaming
  renamed_df <- samples_current_type_with_groups %>%
    dplyr::mutate(Methylation_Profile_Group_Renamed = dplyr::recode(Methylation_Profile_Group, !!!inverse_renaming_map))
  
  message(paste0("    Renamed '", unmethylated_group_name, "' to '", paste0(current_cancer_type, "_Unmethylated"), "' (Avg Beta: ", round(group_avg_betas$average_beta[1], 3), ")"))
  message(paste0("    Renamed '", methylated_group_name, "' to '", paste0(current_cancer_type, "_Methylated"), "' (Avg Beta: ", round(group_avg_betas$average_beta[2], 3), ")"))
  
  renamed_clinical_data_parts[[current_cancer_type]] <- renamed_df
  
  rm(samples_current_type_with_groups, methylation_wide_for_clustering_raw_current_type_for_rename,
     methylation_wide_for_clustering_current_type_for_rename, methylation_mad_for_clustering_current_type_for_rename,
     selected_cpgs_for_clustering_current_type_for_rename, methylation_data_filtered_for_rename,
     group_avg_betas, renamed_df)
  gc()
}

# Combine the renamed parts and update clinical_data_merged
if (length(renamed_clinical_data_parts) > 0) {
  all_renamed_parts_df <- dplyr::bind_rows(renamed_clinical_data_parts)
  
  # Merge the renamed column back into the main clinical_data_merged
  clinical_data_merged <- clinical_data_merged %>%
    dplyr::left_join(all_renamed_parts_df %>% dplyr::select(sample, Methylation_Profile_Group_Renamed), by = "sample") %>%
    dplyr::mutate(Methylation_Profile_Group_Renamed = ifelse(is.na(Methylation_Profile_Group_Renamed),
                                                             Methylation_Profile_Group, # Keep original if not renamed (e.g., Not_Clustered)
                                                             Methylation_Profile_Group_Renamed)) # Use renamed if available
  
  # Optionally, you can now replace the original Methylation_Profile_Group with the renamed one:
  clinical_data_merged <- clinical_data_merged %>%
    dplyr::mutate(Methylation_Profile_Group = Methylation_Profile_Group_Renamed) %>%
    dplyr::select(-Methylation_Profile_Group_Renamed) # Remove temporary column
  
  message("\nUpdated clinical_data_merged with more descriptive Methylation Profile Group names.")
} else {
  message("\nNo methylation groups were renamed as no eligible cancer types were processed.")
}

# Re-save the clinical_data_merged with new names
clustering_results_path_renamed <- file.path(output_dir, "methylation_clustering_results_renamed.csv")
write_csv(clinical_data_merged, clustering_results_path_renamed)
message(paste0("Methylation clustering results (clinical_data_merged) with renamed groups saved to: ", clustering_results_path_renamed))

# Display a sample of the updated metadata with renamed groups
message("\nSample of clinical_data_merged with RENAMED Methylation Profile Groups:")
print(head(clinical_data_merged))

# Check the distribution of new subtypes (renamed)
message("\nDistribution of RENAMED Methylation Profile Groups:")
clinical_data_merged %>%
  dplyr::group_by(cancer_type_fullname, Methylation_Profile_Group) %>%
  dplyr::summarise(count = n(), .groups = 'drop') %>%
  print()

################################################################################
######### Section 3: Data Integration (Creating final_merged_data) ############# 
################################################################################

message("\n--- Section 3: Integrating Clinical and Drug Data ---")

# Merge clinical data (which now includes methylation subgroups) with drug sensitivity data.
# Note: We are NOT merging RNA-seq or full methylation data here to avoid memory issues.
# Those will be joined on demand in later sections (e.g., DE analysis, predictive modeling).
final_merged_data <- clinical_data_merged %>%
  dplyr::left_join(drug_data_wide %>% tibble::rownames_to_column("sample"), by = "sample") %>%
  # Filter to only samples present in both clinical and drug data, and only selected cancer types
  dplyr::filter(sample %in% rownames(drug_data_wide)) %>%
  dplyr::filter(cancer_type_fullname %in% pediatric_glioma_subtypes_of_interest) %>%
  drop_na(Methylation_Profile_Group) # Ensure only samples with a methylation group are kept

message(paste0("Created final_merged_data with ", nrow(final_merged_data), " samples (clinical + drug + methylation subgroups)."))

# Display a sample of the final_merged_data
message("\nSample of final_merged_data:")
print(head(final_merged_data))



################################################################################
########## Section 5: Drug Sensitivity Analysis and Visualization ##############
################################################################################

message("\n--- Section 5: Drug Sensitivity Analysis and Visualization ---")

# Define a global 'drugs_of_interest' list somewhere early in your script
# For example, in Section 1 or a dedicated configuration section:
# **FIX APPLIED HERE:** Updated Octopamine name to match common format with "HCl"
drugs_of_interest <- c("Trametinib (GSK1120212)", "Gefitinib (ZD1839)", "Cisplatin", "(+)-Camphor", "(+,-)-Octopamine HCl", "(+/-)-Sulfinpyrazone")
# Ensure this list contains the BASE names of your drugs (without "drug_")
# -----------------------------------------------------------------------------

# Ensure output directory for drug plots exists
drug_plots_dir <- file.path(output_dir, "Drug_Response_Plots")
if (!dir.exists(drug_plots_dir)) {
  dir.create(drug_plots_dir, recursive = TRUE)
  message(paste0("Created drug response plots directory: ", drug_plots_dir))
}

# --- Diagnostic Step 1: Inspect the global 'drugs_of_interest' ---
message("\n--- Diagnostic: Checking 'drugs_of_interest' ---")
print(drugs_of_interest)

# --- Diagnostic Step 2: Get ALL drug columns from final_merged_data ---
message("\n--- Diagnostic: Actual drug columns in final_merged_data ---")
all_actual_drug_cols <- names(final_merged_data)[startsWith(names(final_merged_data), "drug_")]
print(all_actual_drug_cols)

# --- Diagnostic Step 3: Compare expected vs. actual (base names) ---
message("\n--- Diagnostic: Comparison of base drug names ---")
# Get base names from actual data columns
base_names_in_data <- gsub("drug_", "", all_actual_drug_cols)

# Find which drugs from your 'drugs_of_interest' are missing in the data
missing_drugs_from_interest <- setdiff(drugs_of_interest, base_names_in_data)
if (length(missing_drugs_from_interest) > 0) {
  message(paste0("The following drugs from your 'drugs_of_interest' list are NOT found in final_merged_data: ",
                 paste(missing_drugs_from_interest, collapse = ", ")))
} else {
  message("All drugs from 'drugs_of_interest' are present in final_merged_data.")
}

# Find which drugs in data are NOT in your 'drugs_of_interest' list (optional, but good for discovery)
drugs_in_data_not_in_interest_list <- setdiff(base_names_in_data, drugs_of_interest)
if (length(drugs_in_data_not_in_interest_list) > 0) {
  message(paste0("The following drugs are in final_merged_data but NOT in your 'drugs_of_interest' list: ",
                 paste(drugs_in_data_not_in_interest_list, collapse = ", ")))
} else {
  message("All drugs in final_merged_data (starting with 'drug_') are included in your 'drugs_of_interest' list.")
}

# --- Diagnostic Step 4: What are the 'full_drug_cols_for_plot' built from 'drugs_of_interest'? ---
message("\n--- Diagnostic: 'full_drug_cols_for_plot' generated ---")
full_drug_cols_for_plot <- paste0("drug_", drugs_of_interest)
print(full_drug_cols_for_plot)

# --- Diagnostic Step 5: What ends up in 'selected_drugs_in_data'? ---
message("\n--- Diagnostic: 'selected_drugs_in_data' (actual drugs to be plotted) ---")
selected_drugs_in_data <- full_drug_cols_for_plot[full_drug_cols_for_plot %in% colnames(final_merged_data)]
print(selected_drugs_in_data)

# 5.1 Box Plot of Drug Sensitivity by Methylation Group
message("\n--- Section 5.1: Generating Box Plots for Selected Drug Responses by Methylation Group ---")

# Construct full drug column names with "drug_" prefix from the base drugs_of_interest
full_drug_cols_for_plot <- paste0("drug_", drugs_of_interest)

# Filter these to only include those actually present in final_merged_data
selected_drugs_in_data <- full_drug_cols_for_plot[full_drug_cols_for_plot %in% colnames(final_merged_data)]

if (length(selected_drugs_in_data) == 0) {
  message("No valid selected drugs from 'drugs_of_interest' found in final_merged_data. Skipping drug response plots.")
} else {
  message(paste0("Found ", length(selected_drugs_in_data), " drugs to plot: ",
                 paste(gsub("drug_", "", selected_drugs_in_data), collapse = ", ")))
  
  # Prepare data for plotting: pivot longer and clean drug names
  drug_data_for_plot <- final_merged_data %>%
    dplyr::filter(cancer_type_fullname %in% pediatric_glioma_subtypes_of_interest) %>% # Filter for relevant cancer types early
    dplyr::filter(Methylation_Profile_Group != "Not_Clustered") %>% # Only include clustered samples
    dplyr::select(sample, cancer_type_fullname, Methylation_Profile_Group, all_of(selected_drugs_in_data)) %>%
    tidyr::pivot_longer(
      cols = starts_with("drug_"),
      names_to = "Drug_Full_Name", # Keep original name for now
      values_to = "Z_Score_Response"
    ) %>%
    drop_na(Z_Score_Response) %>%
    dplyr::mutate(Drug = gsub("drug_", "", Drug_Full_Name)) %>% # Cleaned name for plotting
    dplyr::mutate(
      # Convert Methylation_Profile_Group to factor for consistent plotting order
      Methylation_Profile_Group = factor(Methylation_Profile_Group)
    )
  
  # Check if any data remains after filtering and pivoting
  if (nrow(drug_data_for_plot) == 0) {
    message("No drug response data found for selected drugs after filtering. Skipping plots.")
  } else {
    
    # Define common comparisons for stat_compare_means (assuming only two groups per cancer type after renaming)
    # This comparison assumes the two groups will be "X_Unmethylated" and "X_Methylated"
    # It's safer to determine groups per facet
    # However, if your Methylation_Profile_Group is consistently "Unmethylated" and "Methylated" for each type,
    # and you want to compare those specific two, you can do:
    my_comparisons <- list(
      paste0(unique(gsub("_Unmethylated|_Methylated", "", drug_data_for_plot$Methylation_Profile_Group)), "_Unmethylated"),
      paste0(unique(gsub("_Unmethylated|_Methylated", "", drug_data_for_plot$Methylation_Profile_Group)), "_Methylated")
    )
    # A more general approach is often to let ggsignif handle it, or specify just (group1, group2) for each facet
    # For simplicity with stat_compare_means, letting it auto-detect often works:
    # stat_compare_means(method = "wilcox.test", label = "p.signif", hide.ns = TRUE) # no comparisons argument
    
    # --- Plot 1: Faceted by Drug (all cancer types together per drug) ---
    plot_drug_response_path <- file.path(drug_plots_dir, "Selected_Drugs_Response_by_MethylationGroup.png")
    png(plot_drug_response_path, width = 1400, height = 900, res = 100)
    p_drug_resp <- ggplot(drug_data_for_plot, aes(x = Methylation_Profile_Group, y = Z_Score_Response, fill = Methylation_Profile_Group)) +
      geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.6, size = 1) +
      labs(
        title = "Selected Drug Responses by Methylation Profile Group",
        x = "Methylation Profile Group",
        y = "Drug Sensitivity Z-Score",
        fill = "Methylation Group"
      ) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) + # Angle x-axis labels, adjust size
      facet_wrap(~ Drug, scales = "free_y", ncol = min(length(unique(drug_data_for_plot$Drug)), 3)) + # Separate plot for each drug, limit columns
      # Using group_by and then stat_compare_means, it should apply comparisons per facet
      # You can try without the 'comparisons' argument first for simplicity:
      stat_compare_means(method = "wilcox.test", label = "p.signif", hide.ns = TRUE,
                         aes(group = Methylation_Profile_Group)) # Explicitly group for stat_compare_means
    print(p_drug_resp)
    dev.off()
    message(paste0("Selected drug response plot saved to: ", plot_drug_response_path))
    
    # --- Plot 2: Faceted by Cancer Type and then by Drug (more granular) ---
    # Ensure there are at least 2 groups per facet for stat_compare_means to work
    drug_data_for_facet_grid_plot <- drug_data_for_plot %>%
      dplyr::group_by(cancer_type_fullname, Drug) %>%
      dplyr::filter(length(unique(Methylation_Profile_Group)) > 1 && n() >= 4) %>% # At least 2 groups and 4 samples per facet
      dplyr::ungroup()
    
    if (nrow(drug_data_for_facet_grid_plot) == 0) {
      message("Not enough data to generate granular drug response plot (faceted by Cancer Type and Drug). Skipping.")
    } else {
      plot_drug_response_facet_path <- file.path(drug_plots_dir, "Selected_Drugs_Response_by_MethylationGroup_Facet_CancerType_Drug.png")
      png(plot_drug_response_facet_path, width = 2000, height = 1200, res = 100)
      p_drug_resp_facet <- ggplot(drug_data_for_facet_grid_plot, aes(x = Methylation_Profile_Group, y = Z_Score_Response, fill = Methylation_Profile_Group)) +
        geom_boxplot(outlier.shape = NA) +
        geom_jitter(width = 0.2, alpha = 0.6, size = 1) +
        labs(
          title = "Selected Drug Responses by Methylation Profile Group (Faceted by Cancer Type and Drug)",
          x = "Methylation Profile Group",
          y = "Drug Sensitivity Z-Score",
          fill = "Methylation Group"
        ) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5),
              strip.text = element_text(face = "bold", size = 10),
              axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
              axis.title = element_text(size = 10),
              legend.position = "bottom") +
        facet_grid(Drug ~ cancer_type_fullname, scales = "free") + # Grid by Drug and Cancer Type
        stat_compare_means(method = "wilcox.test", label = "p.signif", hide.ns = TRUE,
                           aes(group = Methylation_Profile_Group)) # Explicitly group for stat_compare_means
      print(p_drug_resp_facet)
      dev.off()
      message(paste0("Selected drug response (faceted) plot saved to: ", plot_drug_response_facet_path))
    }
    
    rm(drug_data_for_plot, drug_data_for_facet_grid_plot)
    gc()
  }
}

################################################################################
########### 6. Differential Expression Analysis (RNA-seq) ######################
################################################################################

message("\n--- Section 6: Differential Expression Analysis (RNA-seq) by Methylation Profile Group ---")

# Ensure output directory for DE results exists
de_output_dir <- file.path(output_dir, "Differential_Expression_Results")
if (!dir.exists(de_output_dir)) {
  dir.create(de_output_dir, recursive = TRUE)
  message(paste0("Created DE results directory: ", de_output_dir))
}

# Identifying eligible cancer types for Differential Expression analysis based on Methylation Profile Groups
# Criteria: At least 2 methylation groups, each with at least 3 samples
message("\nIdentifying eligible cancer types for DE analysis based on Methylation Profile Groups...")

# Use clinical_data_merged which has sample and Methylation_Profile_Group
# IMPORTANT: Filter out "Not_Clustered" here for the initial eligibility check
de_eligible_cancer_types <- clinical_data_merged %>%
  dplyr::filter(Methylation_Profile_Group != "Not_Clustered") %>% # Exclude "Not_Clustered" samples here
  dplyr::group_by(cancer_type_fullname, Methylation_Profile_Group) %>%
  dplyr::summarise(n_samples = n(), .groups = 'drop') %>%
  dplyr::group_by(cancer_type_fullname) %>%
  dplyr::filter(n() >= 2 & all(n_samples >= 3)) %>% # At least 2 groups, each with >=3 samples
  dplyr::pull(cancer_type_fullname) %>% unique()

if (length(de_eligible_cancer_types) == 0) {
  message("No cancer types found with at least 3 samples in at least two methylation profile groups for DE analysis. Skipping this section.")
} else {
  message(paste0("Found ", length(de_eligible_cancer_types), " cancer types eligible for DE analysis."))
  
  # Loop through each eligible cancer type
  for (current_cancer_type in de_eligible_cancer_types) {
    message(paste0("\n Performing DE analysis for: ", current_cancer_type, " (by Methylation Profile Groups)"))
    
    # Filter clinical data for the current cancer type and prepare for limma
    # IMPORTANT: Join with the global rnaseq_data (long format) only when needed for DE analysis
    current_clinical_for_de <- clinical_data_merged %>% # Using clinical_data_merged
      dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
      dplyr::select(sample, Methylation_Profile_Group) %>%
      drop_na(Methylation_Profile_Group) %>%
      dplyr::filter(Methylation_Profile_Group != "Not_Clustered") # Exclude "Not_Clustered" samples
    
    current_rnaseq_for_de <- rnaseq_data %>% # Use the global long RNA-seq data object
      dplyr::filter(sample %in% current_clinical_for_de$sample) %>%
      dplyr::left_join(current_clinical_for_de, by = "sample") %>%
      dplyr::select(sample, geneid, expression_value, Methylation_Profile_Group) %>%
      drop_na(expression_value) # Remove any NA expression values
    
    # --- DEBUGGING START (Keep these for further verification if needed) ---
    message(paste0("DEBUG: Inside DE loop for current_cancer_type: ", current_cancer_type))
    
    message("DEBUG: Counts from clinical_data_merged for this cancer type (after excluding Not_Clustered):")
    print(current_clinical_for_de %>% dplyr::count(Methylation_Profile_Group))
    
    message("DEBUG: Counts from rnaseq_data after filtering and joining (before pivoting and final check):")
    current_rnaseq_for_de_summary <- current_rnaseq_for_de %>%
      dplyr::distinct(sample, Methylation_Profile_Group) %>%
      dplyr::count(Methylation_Profile_Group)
    print(current_rnaseq_for_de_summary)
    
    message(paste0("DEBUG: Number of distinct groups remaining (after rnaseq join & NA removal): ", nrow(current_rnaseq_for_de_summary)))
    if(nrow(current_rnaseq_for_de_summary) > 0) {
      message(paste0("DEBUG: Minimum samples in any group (after rnaseq join & NA removal): ", min(current_rnaseq_for_de_summary$n)))
    } else {
      message("DEBUG: No samples remaining after rnaseq join and NA removal.")
    }
    # --- DEBUGGING END ---
    
    
    # Ensure there are enough samples per group for this cancer type
    group_counts <- current_rnaseq_for_de %>%
      dplyr::distinct(sample, Methylation_Profile_Group) %>%
      dplyr::count(Methylation_Profile_Group)
    
    if (nrow(group_counts) < 2 || any(group_counts$n < 3)) {
      message(paste0("Skipping ", current_cancer_type, ": Insufficient samples in methylation profile groups for DE analysis after filtering for current cancer type."))
      next
    }
    
    # Pivot RNA-seq data to wide format (genes as rows, samples as columns) for limma
    expression_matrix <- current_rnaseq_for_de %>%
      dplyr::select(geneid, sample, expression_value) %>%
      tidyr::pivot_wider(names_from = sample, values_from = expression_value) %>%
      tibble::column_to_rownames("geneid")
    
    # Ensure all values are numeric
    expression_matrix <- as.matrix(expression_matrix)
    expression_matrix[is.na(expression_matrix)] <- 0 # Impute with 0 for DE analysis if values are missing (or consider other strategies)
    
    # Create design matrix
    sample_metadata <- current_rnaseq_for_de %>%
      dplyr::distinct(sample, Methylation_Profile_Group) %>%
      dplyr::filter(sample %in% colnames(expression_matrix)) %>% # Keep only samples present in matrix
      dplyr::arrange(match(sample, colnames(expression_matrix))) # Ensure order matches matrix columns
    
    # Convert Methylation_Profile_Group to factor
    sample_metadata$Methylation_Profile_Group <- factor(sample_metadata$Methylation_Profile_Group)
    
    # Get original levels and create syntactically valid names for them
    original_levels <- levels(sample_metadata$Methylation_Profile_Group)
    valid_levels <- make.names(original_levels)
    
    # Map the factor levels to the valid names. This ensures model.matrix uses these.
    levels(sample_metadata$Methylation_Profile_Group) <- valid_levels
    
    # Now create the design matrix using the factor with valid levels
    design <- model.matrix(~0 + Methylation_Profile_Group, data = sample_metadata)
    # Explicitly ensure design matrix column names match the valid_levels
    colnames(design) <- valid_levels
    
    
    if (nlevels(sample_metadata$Methylation_Profile_Group) == 2) {
      contrast_matrix_formula <- paste(valid_levels[1], "-", valid_levels[2]) # Use valid_levels here
      contrast.matrix <- limma::makeContrasts(contrasts = contrast_matrix_formula, levels = design)
      
      message(paste0("    Comparing: ", contrast_matrix_formula))
      
    } else if (nlevels(sample_metadata$Methylation_Profile_Group) > 2) {
      contrast_list <- lapply(valid_levels, function(g) { # Use valid_levels here
        others <- setdiff(valid_levels, g) # Use valid_levels here
        paste0(g, " - (", paste(others, collapse = "+"), ")/", length(others))
      })
      contrast.matrix <- limma::makeContrasts(contrasts = unlist(contrast_list), levels = design)
      message(paste0("    Comparing each group against others for ", nlevels(sample_metadata$Methylation_Profile_Group), " groups."))
      
    } else {
      message(paste0("  Skipping ", current_cancer_type, ": Only one methylation profile group or invalid groups for DE analysis."))
      next
    }
    
    # Fit linear model
    fit <- limma::lmFit(expression_matrix, design) # Explicitly use limma::lmFit
    fit <- limma::contrasts.fit(fit, contrast.matrix) # Explicitly use limma::contrasts.fit
    fit <- limma::eBayes(fit) # Explicitly use limma::eBayes
    
    # Extract top differentially expressed genes for each contrast
    for (contrast_name in colnames(contrast.matrix)) {
      top_genes <- limma::topTable(fit, coef = contrast_name, number = Inf, adjust.method = "BH") %>% # Explicitly use limma::topTable
        tibble::rownames_to_column("geneid") %>%
        dplyr::filter(P.Value < 0.05) # Filter for significance
      
      if (nrow(top_genes) > 0) {
        # Add gene symbols to the DE results
        top_genes_annotated <- top_genes %>%
          dplyr::left_join(gene_symbol_map_df %>% dplyr::select(geneid, gene, description), by = "geneid")
        
        # --- REVISED MODIFICATION FOR SHORTER FILENAME START ---
        short_contrast_name <- ""
        if (grepl(" - ", contrast_name)) { # This is for "GroupA - GroupB" comparisons
          parts <- strsplit(contrast_name, " - ")[[1]]
          
          # Extract the part after the LAST underscore or LAST dot.
          # This targets group names like "Adult.High.Grade.Glioma_Methylated" -> "Methylated"
          group1_short <- sub(".*[._]", "", parts[1])
          group2_short <- sub(".*[._]", "", parts[2])
          
          # Combine to form the short contrast name
          short_contrast_name <- paste0(group1_short, "_vs_", group2_short)
          
        } else if (grepl("_vs_Others$", contrast_name)) { # This is for "GroupX_vs_Others" comparisons
          # Extract just the group name before "_vs_Others"
          group_base_name <- gsub("_vs_Others$", "", contrast_name)
          # Remove the cancer type prefix from the group base name if it exists (e.g., "Adult.High.Grade.Glioma.")
          # Use make.names to convert the original cancer type to a format that might be in the group name
          cleaned_cancer_type_for_match <- make.names(current_cancer_type)
          # Escape dots for regex, in case make.names introduced them and we're matching literally
          cleaned_cancer_type_for_match <- gsub("\\.", "\\\\.", cleaned_cancer_type_for_match)
          
          group_base_name <- gsub(paste0("^", cleaned_cancer_type_for_match, "[_.]?"), "", group_base_name)
          
          # Combine to form the short contrast name
          short_contrast_name <- paste0(group_base_name, "_vs_Others")
          
        } else { # Fallback for any other unexpected contrast format, sanitize it
          short_contrast_name <- gsub("[^A-Za-z0-9_.]", "_", contrast_name)
        }
        
        # Ensure cancer type name is clean for filename (replace spaces/special chars with underscores/dots, collapse multiples)
        clean_cancer_type <- gsub("[^A-Za-z0-9_.]", "_", current_cancer_type)
        clean_cancer_type <- gsub("[._]{2,}","_", clean_cancer_type)
        clean_cancer_type <- gsub("^_|_$", "", clean_cancer_type)
        
        # Final sanitization for the short_contrast_name itself
        short_contrast_name <- gsub("[^A-Za-z0-9_.]", "_", short_contrast_name)
        short_contrast_name <- gsub("[._]{2,}", "_", short_contrast_name) # Collapse multiple dots/underscores
        short_contrast_name <- gsub("^_|_$", "", short_contrast_name) # Trim leading/trailing if any
        
        de_filename <- paste0("DE_Genes_", clean_cancer_type, "_", short_contrast_name, ".csv")
        # --- REVISED MODIFICATION FOR SHORTER FILENAME END ---
        
        write_csv(top_genes_annotated, file.path(de_output_dir, de_filename))
        message(paste0("Saved ", nrow(top_genes_annotated), " DE genes for contrast '", contrast_name, "': ", file.path(de_output_dir, de_filename)))
      } else {
        message(paste0("No significant DE genes for contrast '", contrast_name, "' in ", current_cancer_type, "."))
      }
    }
    rm(current_rnaseq_for_de, expression_matrix, sample_metadata, design, contrast.matrix, fit)
    gc()
  } # End of cancer type loop for DE
}

################################################################################
########### Section 7: Pathway and Functional Enrichment Analysis ##############
################################################################################

message("\n--- Section 7: Pathway and Functional Enrichment Analysis for DE Genes ---")

# Ensure output directory for Pathway results exists
pathway_output_dir <- file.path(output_dir, "Pathway_Enrichment_Results")
if (!dir.exists(pathway_output_dir)) {
  dir.create(pathway_output_dir, recursive = TRUE)
  message(paste0("Created pathway enrichment results directory: ", pathway_output_dir))
}

# Load clusterProfiler and annotation packages (if not already loaded in setup)
# If you don't have these, you might need to install them:
# BiocManager::install("clusterProfiler")
# BiocManager::install("org.Hs.eg.db") # For Homo sapiens gene annotations
library(clusterProfiler)
library(org.Hs.eg.db) # For human gene annotations (Entrez IDs needed for KEGG)

# Loop through each eligible cancer type (same as in DE analysis)
for (current_cancer_type in de_eligible_cancer_types) {
  message(paste0("\n  Performing Pathway Analysis for: ", current_cancer_type))
  
  # Loop through contrasts for each cancer type
  # You'll need to re-derive the contrast names or load them
  # A simpler way is to just read all DE files for the current cancer type
  
  # Clean cancer type name for file matching
  clean_cancer_type <- gsub("[^A-Za-z0-9_.]", "_", current_cancer_type)
  clean_cancer_type <- gsub("[._]{2,}","_", clean_cancer_type)
  clean_cancer_type <- gsub("^_|_$", "", clean_cancer_type)
  
  # List all DE gene files for the current cancer type
  de_files <- list.files(de_output_dir, pattern = paste0("^DE_Genes_", clean_cancer_type, ".*\\.csv$"), full.names = TRUE)
  
  if (length(de_files) == 0) {
    message(paste0("  No DE gene files found for ", current_cancer_type, ". Skipping pathway analysis for this type."))
    next
  }
  
  for (de_file in de_files) {
    # Extract contrast name from filename
    contrast_filename_part <- gsub(paste0("^DE_Genes_", clean_cancer_type, "_"), "", basename(de_file))
    contrast_name_clean <- gsub("\\.csv$", "", contrast_filename_part)
    message(paste0("    Processing contrast: ", contrast_name_clean))
    
    de_results <- read_csv(de_file, show_col_types = FALSE)
    
    if (nrow(de_results) == 0) {
      message("      No significant DE genes in this file. Skipping pathway analysis.")
      next
    }
    
    # Prepare gene list for clusterProfiler
    # Entrez IDs are often preferred for KEGG and some GO analyses.
    # We have 'geneid' (Ensembl) and 'gene' (HGNC symbol).
    # Need to map to Entrez ID if not already available in your gene_symbol_map_df.
    
    # Option 1: Map HGNC symbol to Entrez ID
    # Ensure your gene_symbol_map_df has Entrez IDs, or perform mapping here
    # For simplicity, let's try mapping from HGNC symbol using org.Hs.eg.db
    # This might require some filtering as not all HGNC symbols map one-to-one to Entrez.
    
    genes_for_enrichment <- de_results %>%
      dplyr::filter(!is.na(gene) & gene != "") %>% # Ensure gene symbol exists
      dplyr::pull(gene) # Get HGNC symbols
    
    # Mapping HGNC symbols to Entrez IDs
    # This is important for KEGG and some GO analyses in clusterProfiler
    entrez_ids <- suppressMessages(
      AnnotationDbi::mapIds(org.Hs.eg.db,
                            keys = genes_for_enrichment,
                            column = "ENTREZID",
                            keytype = "SYMBOL",
                            multiVals = "first") # Take the first if multiple Entrez IDs map to one symbol
    )
    
    # Filter out NA Entrez IDs
    entrez_genes <- na.omit(entrez_ids)
    
    if (length(entrez_genes) == 0) {
      message("      No valid Entrez IDs found for DE genes. Skipping pathway analysis for this contrast.")
      next
    }
    
    # Perform GO Enrichment (Biological Process, Cellular Component, Molecular Function)
    message("      Performing GO Enrichment...")
    go_enrich <- tryCatch({
      enrichGO(gene = entrez_genes,
               OrgDb = org.Hs.eg.db,
               keyType = "ENTREZID",
               ont = "BP", # Biological Process. Can also be "CC" (Cellular Component) or "MF" (Molecular Function)
               pAdjustMethod = "BH",
               pvalueCutoff = 0.05,
               qvalueCutoff = 0.05,
               readable = TRUE) # Convert Entrez ID to gene symbol
    }, error = function(e) {
      message(paste0("      Error in GO enrichment for ", contrast_name_clean, ": ", e$message))
      return(NULL)
    })
    
    if (!is.null(go_enrich) && nrow(go_enrich@result) > 0) {
      go_df <- as.data.frame(go_enrich)
      go_filename <- file.path(pathway_output_dir, paste0("GO_BP_Enrichment_", clean_cancer_type, "_", contrast_name_clean, ".csv"))
      write_csv(go_df, go_filename)
      message(paste0("      Saved GO-BP enrichment results to: ", go_filename))
      
      # Optional: Visualize top GO terms (e.g., top 10)
      if (nrow(go_df) > 0) {
        go_plot_filename <- file.path(pathway_output_dir, paste0("GO_BP_Barplot_", clean_cancer_type, "_", contrast_name_clean, ".png"))
        png(go_plot_filename, width = 1000, height = 700, res = 100)
        # Order by adjusted p-value and take top 10, or fewer if not 10
        # The 'barplot' function from clusterProfiler directly handles the enriched object
        print(barplot(go_enrich, showCategory = min(10, nrow(go_df)), 
                      title = paste0("Top GO Biological Processes for ", gsub("_", " ", clean_cancer_type), "\n(", gsub("_", " ", contrast_name_clean), ")")))
        dev.off()
        message(paste0("      Saved GO-BP barplot to: ", go_plot_filename))
      }
    } else {
      message("      No significant GO-BP terms found.")
    }
    
    # Perform KEGG Pathway Enrichment
    message("      Performing KEGG Enrichment...")
    kegg_enrich <- tryCatch({
      enrichKEGG(gene = entrez_genes,
                 organism = 'hsa', # Homo sapiens
                 pAdjustMethod = "BH",
                 pvalueCutoff = 0.05,
                 qvalueCutoff = 0.05)
    }, error = function(e) {
      message(paste0("      Error in KEGG enrichment for ", contrast_name_clean, ": ", e$message))
      return(NULL)
    })
    
    if (!is.null(kegg_enrich) && nrow(kegg_enrich@result) > 0) {
      kegg_df <- as.data.frame(kegg_enrich)
      kegg_filename <- file.path(pathway_output_dir, paste0("KEGG_Enrichment_", clean_cancer_type, "_", contrast_name_clean, ".csv"))
      write_csv(kegg_df, kegg_filename)
      message(paste0("      Saved KEGG enrichment results to: ", kegg_filename))
      
      # Optional: Visualize top KEGG terms (e.g., top 10)
      if (nrow(kegg_df) > 0) {
        kegg_plot_filename <- file.path(pathway_output_dir, paste0("KEGG_Barplot_", clean_cancer_type, "_", contrast_name_clean, ".png"))
        png(kegg_plot_filename, width = 1000, height = 700, res = 100)
        # The 'barplot' function from clusterProfiler directly handles the enriched object
        print(barplot(kegg_enrich, showCategory = min(10, nrow(kegg_df)), 
                      title = paste0("Top KEGG Pathways for ", gsub("_", " ", clean_cancer_type), "\n(", gsub("_", " ", contrast_name_clean), ")")))
        dev.off()
        message(paste0("      Saved KEGG barplot to: ", kegg_plot_filename))
      }
    } else {
      message("      No significant KEGG pathways found.")
    }
    
    rm(de_results, genes_for_enrichment, entrez_ids, entrez_genes, go_enrich, kegg_enrich)
    gc()
  } # End of DE file loop
} # End of cancer type loop for Pathway Analysis


################################################################################
########## Pre-processing: Extracting Drug Target Information ##################
################################################################################

message("\n--- Pre-processing: Extracting Drug Target Information from raw drug data (using 'rh_target') ---")

# Ensure 'drug_data_original_filepath' is defined from your initial setup (Section 1).
# It should point to the original CSV file in long format, e.g.:
drug_data_original_filepath <- "D:/Laboratorio/Pediatrico/CCMA primary multi-omics datasets/ccma datasets/CCMA_drugscreen_zscores_042024.csv"
if (!exists("drug_data_original_filepath") || !file.exists(drug_data_original_filepath)) {
  stop("Error: 'drug_data_original_filepath' is not defined or the file does not exist. Please define this variable in your initial setup (Section 1) pointing to the original long format drug sensitivity CSV.")
}

# Load the original long format drug data to extract drug-target mapping
drug_data_long_raw_for_target_extraction <- read_csv(drug_data_original_filepath, show_col_types = FALSE)

# Extract unique drug-target mappings and clean them using the 'rh_target' column
drug_target_map_df <- drug_data_long_raw_for_target_extraction %>%
  dplyr::select(drug_name, rh_target) %>% # ***MODIFICATION: Select 'rh_target' column***
  dplyr::distinct() %>% # Get unique combinations
  dplyr::filter(!is.na(rh_target) & rh_target != "") %>% # ***MODIFICATION: Filter 'rh_target' for NA/empty***
  dplyr::mutate(
    # Clean up rh_target string (remove whitespace around)
    rh_target = stringr::str_trim(rh_target),
    # Handle multiple targets separated by commas (and optional whitespace)
    # This creates a list-column, where each element is a vector of individual targets
    targets_split = strsplit(as.character(rh_target), ",\\s*"), # ***MODIFICATION: Use specific comma delimiter***
    # Clean up any residual leading/trailing whitespace on each gene symbol within the list
    targets_split = lapply(targets_split, function(x) trimws(x))
  ) %>%
  dplyr::ungroup() %>%
  dplyr::select(drug_name, targets_split) # Keep only the necessary columns for Section 8

message(paste0("Extracted target information for ", length(unique(drug_target_map_df$drug_name)), " unique drugs with defined targets from 'rh_target'."))
message("Sample of drug_target_map_df (shows drug and a list of its targets from 'rh_target'):")
print(head(drug_target_map_df))

# Clean up memory
rm(drug_data_long_raw_for_target_extraction)
gc()

################################################################################
########## Section 8: Drug Ranking by Methylation Profile Group ##############
################################################################################

# Helper function to clean names for directory and file names, making them safe for paths
# This function is used to create clean, file-system friendly names from cancer types and methylation groups.
clean_name_for_path_extended <- function(name_to_clean, max_len = 50) {
  # Replace punctuation and spaces with underscores
  cleaned_name <- stringr::str_replace_all(name_to_clean, "[[:punct:] ]+", "_")
  # Replace multiple underscores with a single one
  cleaned_name <- stringr::str_replace_all(cleaned_name, "[_]{2,}", "_")
  # Remove leading/trailing underscores
  cleaned_name <- stringr::str_trim(cleaned_name, side = "both")
  
  # Ensure it doesn't start or end with underscore after trimming
  cleaned_name <- sub("^_", "", cleaned_name)
  cleaned_name <- sub("_$", "", cleaned_name)
  
  # Handle potential empty strings after cleaning
  cleaned_name <- ifelse(nchar(cleaned_name) == 0, "Unknown_Group_or_Type", cleaned_name)
  
  # Truncate if still too long to avoid potential OS path issues
  if (nchar(cleaned_name) > max_len) {
    cleaned_name <- substr(cleaned_name, 1, max_len)
  }
  return(cleaned_name)
}


message("\n--- Section 6.5: Generating Drug Ranking by Methylation Profile Group ---")

drug_ranking_output_dir <- file.path(output_dir, "Drug_Ranking_by_Methylation_Group")
if (!dir.exists(drug_ranking_output_dir)) {
  dir.create(drug_ranking_output_dir, recursive = TRUE)
  message(paste0("Created Drug Ranking directory: ", drug_ranking_output_dir))
}

# Directory for plots
drug_ranking_plots_dir <- file.path(drug_ranking_output_dir, "Plots")
if (!dir.exists(drug_ranking_plots_dir)) {
  dir.create(drug_ranking_plots_dir, recursive = TRUE)
  message(paste0("Created Drug Ranking Plots directory: ", drug_ranking_plots_dir))
}

# New directory for Volcano Plots
volcano_plots_dir <- file.path(drug_ranking_output_dir, "Volcano_Plots")
if (!dir.exists(volcano_plots_dir)) {
  dir.create(volcano_plots_dir, recursive = TRUE)
  message(paste0("Created Volcano Plots directory: ", volcano_plots_dir))
}

# Heatmap directory (reverted to single heatmap per cancer type)
# Note: This path seems to be outside the drug_ranking_output_dir, confirm if intended
heatmap_plots_dir <- file.path(output_dir, "Heatmaps")
if (!dir.exists(heatmap_plots_dir)) {
  dir.create(heatmap_plots_dir, recursive = TRUE)
  message(paste0("Created Heatmaps directory: ", heatmap_plots_dir))
}


# Identify drug columns (using the corrected convention 'drug_XXX')
drug_cols_for_ranking <- colnames(final_merged_data)[grepl("^drug_", colnames(final_merged_data))]

if (length(drug_cols_for_ranking) == 0) {
  message("No drug columns starting with 'drug_' found in final_merged_data. Skipping drug ranking.")
} else {
  message(paste0("Found ", length(drug_cols_for_ranking), " drug columns for ranking."))
  
  # Get all unique cancer types from final_merged_data that have methylation group info
  # Ensure we only consider cancer types with sufficient data
  eligible_ranking_cancer_types <- final_merged_data %>%
    dplyr::filter(Methylation_Profile_Group != "Not_Clustered") %>%
    dplyr::group_by(cancer_type_fullname, Methylation_Profile_Group) %>%
    dplyr::summarise(n_samples = n(), .groups = 'drop') %>%
    dplyr::filter(n_samples >= 3) %>% # Require at least 3 samples per group for a meaningful average
    dplyr::pull(cancer_type_fullname) %>% unique()
  
  if (length(eligible_ranking_cancer_types) == 0) {
    message("No cancer types found with eligible methylation groups (>=3 samples) for drug ranking. Skipping.")
  } else {
    message(paste0("Processing drug rankings for ", length(eligible_ranking_cancer_types), " cancer types."))
    
    # Store all drug ranking DFs for later heatmap generation (if applicable)
    all_drug_rankings_list <- list()
    
    for (current_cancer_type in eligible_ranking_cancer_types) {
      message(paste0("\n  Processing drug rankings for cancer type: ", current_cancer_type))
      
      # Filter data for the current cancer type
      current_cancer_data <- final_merged_data %>%
        dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
        dplyr::select(sample, Methylation_Profile_Group, all_of(drug_cols_for_ranking)) %>%
        dplyr::filter(Methylation_Profile_Group != "Not_Clustered") %>% # Exclude Not_Clustered
        drop_na(Methylation_Profile_Group) # Ensure Methylation_Profile_Group is not NA
      
      # Get unique methylation groups for this cancer type that have at least 3 samples
      unique_meth_groups_for_ranking <- current_cancer_data %>%
        dplyr::group_by(Methylation_Profile_Group) %>%
        dplyr::summarise(n_samples = n(), .groups = 'drop') %>%
        dplyr::filter(n_samples >= 3) %>%
        dplyr::pull(Methylation_Profile_Group)
      
      if (length(unique_meth_groups_for_ranking) == 0) {
        message(paste0("    No eligible methylation groups found (>=3 samples) for ", current_cancer_type, ". Skipping."))
        next
      }
      
      for (current_meth_group in unique_meth_groups_for_ranking) {
        message(paste0("    Ranking drugs for group: ", current_meth_group))
        
        # Filter data for the current methylation group
        group_data <- current_cancer_data %>%
          dplyr::filter(Methylation_Profile_Group == current_meth_group)
        
        # Calculate MEDIAN Z-score for each drug in this group
        drug_z_scores <- group_data %>%
          dplyr::select(all_of(drug_cols_for_ranking)) %>%
          summarise_all(list(median = ~median(., na.rm = TRUE)))
        
        # Convert to long format for ranking
        drug_ranking_df <- drug_z_scores %>%
          tidyr::pivot_longer(
            cols = everything(),
            names_to = "Drug_Temp", # Use a temporary name to hold the "drug_XYZ_median" string
            values_to = "Median_Z_Score"
          ) %>%
          dplyr::mutate(
            # First, remove "_median" suffix, then remove "drug_" prefix
            # This regex handles both "drug_DrugName_median" and "drug_DrugName" correctly
            Drug = gsub("^(drug_)?(.+?)(_median)?$", "\\2", Drug_Temp),
            Drug_Temp = NULL # Remove the temporary column
          ) %>%
          dplyr::filter(!is.na(Median_Z_Score)) %>% # Remove drugs with no valid Z-scores
          dplyr::arrange(Median_Z_Score) %>% # Rank by lower Z-score = higher efficacy
          dplyr::mutate(Rank = row_number()) %>%
          dplyr::select(Rank, Drug, Median_Z_Score)
        
        if (nrow(drug_ranking_df) == 0) {
          message(paste0("      No valid drug Z-scores to rank for group '", current_meth_group, "' in '", current_cancer_type, "'. Skipping."))
          next
        }
        
        # --- Specificity Analysis: Comparing target group to other groups within the same cancer type ---
        message(paste0("      Checking drug specificity for group: ", current_meth_group))
        specificity_results <- data.frame(
          Drug = character(),
          P_value_Specificity = numeric(),
          Median_Z_Score_Target = numeric(), # Store target group median
          Median_Z_Score_Other = numeric(),  # Store other group median
          stringsAsFactors = FALSE
        )
        
        other_group_data <- current_cancer_data %>%
          dplyr::filter(Methylation_Profile_Group != current_meth_group & Methylation_Profile_Group != "Not_Clustered")
        
        message(paste0("        Number of samples in 'other_group_data' for specificity comparison: ", nrow(other_group_data)))
        
        if (nrow(other_group_data) > 0) {
          drugs_to_check_specificity <- drug_ranking_df$Drug
          
          message(paste0("        Number of drugs being checked for specificity: ", length(drugs_to_check_specificity)))
          
          for (drug_name_clean in drugs_to_check_specificity) {
            drug_name_raw <- paste0("drug_", drug_name_clean)
            
            if (drug_name_raw %in% colnames(group_data) && drug_name_raw %in% colnames(other_group_data)) {
              z_scores_target_group <- group_data[[drug_name_raw]] %>% na.omit()
              z_scores_other_groups <- other_group_data[[drug_name_raw]] %>% na.omit()
              
              message(paste0("          Drug: ", drug_name_clean, " | Target Group Samples: ", length(z_scores_target_group), " | Other Group Samples: ", length(z_scores_other_groups)))
              
              if (length(z_scores_target_group) >= 3 && length(z_scores_other_groups) >= 3) {
                # Suppress the "cannot compute exact p-value with ties" warning
                suppressWarnings({
                  wilcox_test_result <- wilcox.test(z_scores_target_group, z_scores_other_groups, alternative = "less")
                })
                specificity_results <- rbind(specificity_results,
                                             data.frame(
                                               Drug = drug_name_clean,
                                               P_value_Specificity = wilcox_test_result$p.value,
                                               Median_Z_Score_Target = median(z_scores_target_group),
                                               Median_Z_Score_Other = median(z_scores_other_groups),
                                               stringsAsFactors = FALSE
                                             )
                )
                message(paste0("            Wilcoxon test successful for ", drug_name_clean, ". P-value: ", wilcox_test_result$p.value))
              } else {
                message(paste0("            Skipping specificity test for drug ", drug_name_clean, ": Not enough samples in target (", length(z_scores_target_group), ") or other (", length(z_scores_other_groups), ") groups."))
                specificity_results <- rbind(specificity_results,
                                             data.frame(
                                               Drug = drug_name_clean,
                                               P_value_Specificity = NA,
                                               Median_Z_Score_Target = NA,
                                               Median_Z_Score_Other = NA,
                                               stringsAsFactors = FALSE
                                             )
                )
              }
            } else {
              message(paste0("            Drug column '", drug_name_raw, "' not found in one of the datasets for specificity check. (Original: ", drug_name_clean, ")"))
              specificity_results <- rbind(specificity_results,
                                           data.frame(
                                             Drug = drug_name_clean,
                                             P_value_Specificity = NA,
                                             Median_Z_Score_Target = NA,
                                             Median_Z_Score_Other = NA,
                                             stringsAsFactors = FALSE
                                           )
              )
            }
          }
          
          message(paste0("        Rows in specificity_results before p.adjust: ", nrow(specificity_results)))
          
          if (nrow(specificity_results) > 0 && !all(is.na(specificity_results$P_value_Specificity))) {
            specificity_results$Adjusted_P_value_Specificity <- p.adjust(specificity_results$P_value_Specificity, method = "BH")
            
            drug_ranking_df <- drug_ranking_df %>%
              dplyr::left_join(specificity_results, by = "Drug") %>%
              dplyr::mutate(Is_Specific = ifelse(!is.na(Adjusted_P_value_Specificity) & Adjusted_P_value_Specificity < 0.05, TRUE, FALSE),
                            Difference_Z_Score = Median_Z_Score_Target - Median_Z_Score_Other)
          } else {
            message("      No valid specificity results generated for this group after individual drug checks. Setting all to NA/FALSE.")
            drug_ranking_df$P_value_Specificity <- NA
            drug_ranking_df$Adjusted_P_value_Specificity <- NA
            drug_ranking_df$Is_Specific <- FALSE
            drug_ranking_df$Median_Z_Score_Target <- NA
            drug_ranking_df$Median_Z_Score_Other <- NA
            drug_ranking_df$Difference_Z_Score <- NA
          }
        } else {
          message(paste0("      No 'other' eligible groups (>=3 samples) found for specificity comparison for ", current_cancer_type, " - ", current_meth_group, ". Setting all specificity columns to NA/FALSE."))
          drug_ranking_df$P_value_Specificity <- NA
          drug_ranking_df$Adjusted_P_value_Specificity <- NA
          drug_ranking_df$Is_Specific <- FALSE
          drug_ranking_df$Median_Z_Score_Target <- NA
          drug_ranking_df$Median_Z_Score_Other <- NA
          drug_ranking_df$Difference_Z_Score <- NA
        }
        # --- End Specificity Analysis ---
        
        # --- REVISED FILENAME GENERATION FOR SHORTER NAMES (using helper function) ---
        clean_cancer_type <- clean_name_for_path_extended(current_cancer_type, max_len = 50)
        
        # Start with the original methylation group name for processing
        temp_meth_group_display_name <- current_meth_group
        # Escape special regex characters in the cancer type name for 'sub' function
        escaped_cancer_type <- gsub("([][{}()\\*+?./\\^$|])", "\\\\\\1", current_cancer_type)
        temp_meth_group_display_name <- sub(paste0("^", escaped_cancer_type, "[_.-]?"), "", temp_meth_group_display_name)
        
        # If shortening was ineffective (e.g., resulted in an empty string or just underscores/dots),
        # revert to the original full group name for cleaning
        if (nchar(temp_meth_group_display_name) < 3 || grepl("^[._]?$", temp_meth_group_display_name)) {
          temp_meth_group_display_name <- current_meth_group
        }
        
        # Final cleaning for safe filename usage
        clean_meth_group <- clean_name_for_path_extended(temp_meth_group_display_name, max_len = 50)
        
        # Construct the filename
        ranking_filename <- paste0("Drug_Ranking_", clean_cancer_type, "_", clean_meth_group, ".csv")
        # --- END REVISED FILENAME GENERATION ---
        
        write_csv(drug_ranking_df, file.path(drug_ranking_output_dir, ranking_filename))
        message(paste0("      Saved drug ranking for '", current_meth_group, "': ", file.path(drug_ranking_output_dir, ranking_filename)))
        
        # --- PLOTTING TOP 15 DRUGS (Bar Plot) ---
        if (nrow(drug_ranking_df) > 0) {
          # Keep this 'top_15_drugs' as it is, as it's specifically reordered for the bar plot's orientation
          top_15_drugs <- drug_ranking_df %>%
            dplyr::slice_head(n = 15) %>%
            dplyr::mutate(Drug = forcats::fct_reorder(Drug, -Median_Z_Score))
          
          if (nrow(top_15_drugs) > 0) {
            plot_title <- paste0("Top 15 Drugs for ", current_cancer_type, "\nMethylation Group: ", current_meth_group)
            
            p <- ggplot(top_15_drugs, aes(x = Drug, y = Median_Z_Score, fill = Is_Specific)) +
              geom_bar(stat = "identity") +
              scale_fill_manual(values = c("TRUE" = "darkred", "FALSE" = "steelblue"),
                                name = "Methylation Group Specific Drug (Adj P < 0.05)") +
              coord_flip() +
              labs(
                title = plot_title,
                x = "Drug",
                y = "Median Z-Score"
              ) +
              theme_minimal() +
              theme(
                plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
                axis.text.y = element_text(size = 10, face = "bold"),
                axis.text.x = element_text(size = 10),
                axis.title.x = element_text(size = 12, face = "bold"),
                axis.title.y = element_text(size = 12, face = "bold"),
                panel.grid.major.y = element_blank(),
                panel.grid.minor.y = element_blank(),
                legend.position = "bottom"
              )
            
            plot_filename_tiff <- paste0("Top15_Drug_Ranking_", clean_cancer_type, "_", clean_meth_group, ".tiff")
            ggsave(filename = file.path(drug_ranking_plots_dir, plot_filename_tiff), plot = p,
                   width = 14, height = 10, units = "in", dpi = 300, compression = "lzw") # Increased size
            message(paste0("      Saved TIFF plot for '", current_meth_group, "': ", file.path(drug_ranking_plots_dir, plot_filename_tiff)))
            
            plot_filename_jpg <- paste0("Top15_Drug_Ranking_", clean_cancer_type, "_", clean_meth_group, ".jpg")
            ggsave(filename = file.path(drug_ranking_plots_dir, plot_filename_jpg), plot = p,
                   width = 14, height = 10, units = "in", dpi = 300) # Increased size
            message(paste0("      Saved JPG plot for '", current_meth_group, "': ", file.path(drug_ranking_plots_dir, plot_filename_jpg)))
            
          } else {
            message(paste0("      Not enough drugs to plot top 15 for group '", current_meth_group, "' in '", current_cancer_type, "'. Skipping bar plot."))
          }
        }
        
        # --- NEW: Plotting Boxplots for Top 15 Drugs (comparing target vs other groups) ---
        message(paste0("      Generating boxplots for top 15 drugs for group: ", current_meth_group))
        
        if (nrow(drug_ranking_df) > 0 && nrow(other_group_data) > 0) {
          
          # Determine the name for 'Other Groups' based on available methylation groups
          relevant_methylation_groups <- current_cancer_data %>%
            dplyr::filter(Methylation_Profile_Group != "Not_Clustered") %>%
            dplyr::pull(Methylation_Profile_Group) %>%
            unique() %>%
            sort() # Sort for consistent order
          
          other_group_display_name <- "Other Groups" # Default label
          if (length(relevant_methylation_groups) == 2) {
            # If only two relevant groups, use the actual name of the other group
            other_group_display_name <- relevant_methylation_groups[relevant_methylation_groups != current_meth_group]
          }
          
          # Get the top 15 drugs in the *original ranking order* (increasing Z-score)
          # This ensures the boxplots are ordered from left to right as Drug 1, Drug 2, ..., Drug 15
          drugs_ordered_for_boxplot <- drug_ranking_df %>%
            dplyr::slice_head(n = 15) %>% # Take the top 15 which are already ordered by increasing Z-score
            dplyr::pull(Drug) # Get the drug names in that exact order
          
          # Ensure there are drugs to plot
          if (length(drugs_ordered_for_boxplot) == 0) {
            message(paste0("      No top 15 drugs with valid data to plot boxplots for group '", current_meth_group, "' in '", current_cancer_type, "'. Skipping boxplot."))
            next # Skip to the next methylation group if no drugs to plot
          }
          
          # Get the raw drug column names (e.g., "drug_DrugA", "drug_DrugB") for these top 15 clean drug names
          top_15_drug_raw_names <- paste0("drug_", drugs_ordered_for_boxplot)
          
          
          # Combine data from the target group and other groups for the top 15 drugs
          boxplot_data <- bind_rows(
            group_data %>%
              dplyr::select(sample, Methylation_Profile_Group, all_of(top_15_drug_raw_names)),
            other_group_data %>%
              dplyr::select(sample, Methylation_Profile_Group, all_of(top_15_drug_raw_names))
          ) %>%
            tidyr::pivot_longer(
              cols = all_of(top_15_drug_raw_names),
              names_to = "Drug_Raw",
              values_to = "Z_Score"
            ) %>%
            dplyr::mutate(
              # Clean drug name for plotting (remove "drug_" prefix)
              Drug = gsub("^drug_", "", Drug_Raw),
              # Order drugs for the x-axis according to the original ranking (increasing Z-score)
              Drug = forcats::fct_relevel(Drug, drugs_ordered_for_boxplot), # Use the pre-determined order
              # Define group for plotting (Target vs. Other)
              Comparison_Group = ifelse(Methylation_Profile_Group == current_meth_group,
                                        paste0("Target: ", current_meth_group),
                                        other_group_display_name) # Use dynamic name here
            ) %>%
            dplyr::filter(!is.na(Z_Score)) # Remove NA Z-scores for plotting
          
          if (nrow(boxplot_data) > 0) {
            boxplot_title <- paste0("Drug Sensitivity Z-Score Distribution for Top 15 Drugs\n",
                                    current_cancer_type, " - Group: ", current_meth_group)
            
            # Define specific colors for "Target" and the (potentially dynamically named) "Other Groups"
            boxplot_colors_names <- c(paste0("Target: ", current_meth_group), other_group_display_name)
            boxplot_colors_values <- c("darkred", "steelblue")
            boxplot_colors <- setNames(boxplot_colors_values, boxplot_colors_names)
            
            p_boxplot <- ggplot(boxplot_data, aes(x = Drug, y = Z_Score, fill = Comparison_Group)) +
              geom_boxplot(outlier.shape = NA) + # Hide outliers to avoid clutter, especially with many points
              geom_point(position = position_jitterdodge(jitter.width = 0.2), size = 0.5, alpha = 0.6) + # Show individual points
              labs(
                title = boxplot_title,
                x = "Drug",
                y = "Z-Score",
                fill = "Group"
              ) +
              theme_minimal() +
              theme(
                plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
                axis.text.x = element_text(angle = 45, hjust = 1, size = 10, face = "bold"),
                axis.text.y = element_text(size = 10),
                axis.title.x = element_text(size = 12, face = "bold"),
                axis.title.y = element_text(size = 12, face = "bold"),
                legend.position = "bottom"
              ) +
              scale_fill_manual(values = boxplot_colors) # Use defined colors
            
            boxplot_filename_tiff <- paste0("Top15_Drug_Boxplot_", clean_cancer_type, "_", clean_meth_group, ".tiff")
            ggsave(filename = file.path(drug_ranking_plots_dir, boxplot_filename_tiff), plot = p_boxplot,
                   width = 18, height = 10, units = "in", dpi = 300, compression = "lzw") # Increased size
            message(paste0("      Saved TIFF boxplot for '", current_meth_group, "': ", file.path(drug_ranking_plots_dir, boxplot_filename_tiff)))
            
            boxplot_filename_jpg <- paste0("Top15_Drug_Boxplot_", clean_cancer_type, "_", clean_meth_group, ".jpg")
            ggsave(filename = file.path(drug_ranking_plots_dir, boxplot_filename_jpg), plot = p_boxplot,
                   width = 18, height = 10, units = "in", dpi = 300) # Increased size
            message(paste0("      Saved JPG boxplot for '", current_meth_group, "': ", file.path(drug_ranking_plots_dir, boxplot_filename_jpg)))
            
          } else {
            message(paste0("      Not enough valid data points to generate boxplot for top 15 drugs for group '", current_meth_group, "' in '", current_cancer_type, "'. Skipping boxplot."))
          }
        } else {
          message(paste0("      Not enough top 15 drugs or 'other' group data to generate boxplot for group '", current_meth_group, "' in '", current_cancer_type, "'. Skipping boxplot."))
        }
        # --- END Boxplot Plotting ---
        
        # --- NEW: Volcano Plot for Specificity ---
        volcano_data <- drug_ranking_df %>%
          dplyr::filter(!is.na(Difference_Z_Score) & !is.na(Adjusted_P_value_Specificity)) %>%
          dplyr::mutate(
            Log10_Adj_P = -log10(Adjusted_P_value_Specificity),
            Label = ifelse(Is_Specific, Drug, "")
          )
        
        if (nrow(volcano_data) > 0) {
          p_threshold <- 0.05
          diff_z_threshold <- -1 # Default threshold for Z-score difference
          
          top_specific_labels <- volcano_data %>%
            dplyr::filter(Is_Specific) %>%
            dplyr::arrange(Adjusted_P_value_Specificity) %>%
            dplyr::slice_head(n = 5) %>%
            dplyr::pull(Drug)
          
          volcano_data <- volcano_data %>%
            dplyr::mutate(Label = ifelse(Drug %in% top_specific_labels, Drug, ""))
          
          volcano_plot <- ggplot(volcano_data, aes(x = Difference_Z_Score, y = Log10_Adj_P, color = Is_Specific, label = Label)) +
            geom_point(alpha = 0.6, size = 2) +
            geom_vline(xintercept = diff_z_threshold, linetype = "dashed", color = "blue", alpha = 0.7) +
            geom_hline(yintercept = -log10(p_threshold), linetype = "dashed", color = "green", alpha = 0.7) +
            ggrepel::geom_text_repel(box.padding = 0.5, point.padding = 0.5, max.overlaps = Inf, size = 3.5) +
            scale_color_manual(values = c("TRUE" = "darkred", "FALSE" = "grey50"),
                               name = "Methylation Group Specific") +
            labs(
              title = paste0("Drug Specificity Volcano Plot for ", current_cancer_type, "\nMethylation Group: ", current_meth_group),
              x = "Median Z-Score Difference (Target Group - Other Groups)",
              y = "-log10(Adjusted P-value)"
            ) +
            theme_minimal() +
            theme(
              plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
              axis.title = element_text(size = 12, face = "bold"),
              axis.text = element_text(size = 10),
              legend.position = "bottom"
            )
          
          volcano_filename_tiff <- paste0("Volcano_Plot_", clean_cancer_type, "_", clean_meth_group, ".tiff")
          ggsave(filename = file.path(volcano_plots_dir, volcano_filename_tiff), plot = volcano_plot,
                 width = 13, height = 9, units = "in", dpi = 300, compression = "lzw") # Increased size
          message(paste0("      Saved Volcano Plot TIFF for '", current_meth_group, "': ", file.path(volcano_plots_dir, volcano_filename_tiff)))
          
          volcano_filename_jpg <- paste0("Volcano_Plot_", clean_cancer_type, "_", clean_meth_group, ".jpg")
          ggsave(filename = file.path(volcano_plots_dir, volcano_filename_jpg), plot = volcano_plot,
                 width = 13, height = 9, units = "in", dpi = 300) # Increased size
          message(paste0("      Saved Volcano Plot JPG for '", current_meth_group, "': ", file.path(volcano_plots_dir, volcano_filename_jpg)))
          
          
        } else {
          message(paste0("      Not enough data to generate Volcano Plot for group '", current_meth_group, "' in '", current_cancer_type, "'. Skipping."))
        }
        # --- END Volcano Plot ---
        
        # Store drug_ranking_df for later use (e.g. for ordering drugs in heatmap)
        drug_ranking_df$cancer_type_fullname <- current_cancer_type
        drug_ranking_df$Methylation_Profile_Group <- current_meth_group
        all_drug_rankings_list[[length(all_drug_rankings_list) + 1]] <- drug_ranking_df
        
      } # End of methylation group loop
    } # End of cancer type loop
    
    # --- Part 2: Comprehensive Drug Sensitivity Heatmaps (Samples as Columns, Drugs as Rows) ---
    message("\n--- Generating Comprehensive Drug Sensitivity Heatmaps (Samples as Columns, Drugs as Rows) ---")
    
    
    
    # Iterate through each cancer type to generate heatmaps (ONE PER CANCER TYPE)
    for (current_cancer_type in eligible_ranking_cancer_types) {
      message(paste0("  Generating heatmap for cancer type: ", current_cancer_type))
      
      # Get all samples and their methylation groups for this cancer type from the original data
      # Samples will be columns, so we order them here for annotation and matrix construction
      samples_in_cancer_type <- final_merged_data %>%
        dplyr::filter(cancer_type_fullname == current_cancer_type & Methylation_Profile_Group != "Not_Clustered") %>%
        dplyr::select(sample, Methylation_Profile_Group) %>%
        dplyr::distinct() %>%
        dplyr::arrange(Methylation_Profile_Group, sample) # Order samples by group, then alphabetically within group
      
      if (nrow(samples_in_cancer_type) < 3) {
        message(paste0("    Not enough eligible samples (>=3) for ", current_cancer_type, ". Skipping heatmap."))
        next
      }
      
      # Prepare the Z-score matrix for the heatmap
      # Select drugs for the heatmap: all drugs that have at least one valid Z-score in this cancer type's data
      drugs_for_heatmap <- current_cancer_data %>% # Use current_cancer_data which is already filtered by cancer_type
        dplyr::select(all_of(drug_cols_for_ranking)) %>%
        summarise_all(~sum(!is.na(.))) %>% # Count non-NA Z-scores
        tidyr::pivot_longer(cols = everything(), names_to = "Drug_Raw", values_to = "Count_NonNA") %>%
        dplyr::filter(Count_NonNA > 0) %>% # Only include drugs with at least one data point
        dplyr::mutate(Drug = gsub("^(drug_)?(.+?)(_median)?$", "\\2", Drug_Raw)) %>%
        dplyr::pull(Drug)
      
      if (length(drugs_for_heatmap) < 2) { # Need at least two drugs for a meaningful heatmap
        message(paste0("    Not enough drugs with data for ", current_cancer_type, ". Skipping heatmap."))
        next
      }
      
      # Filter final_merged_data to only include samples and drugs relevant for the heatmap
      # Samples are columns, Drugs are rows -> so we build the matrix with samples as rows, drugs as cols, then transpose
      heatmap_data_raw_temp <- final_merged_data %>%
        dplyr::filter(cancer_type_fullname == current_cancer_type & Methylation_Profile_Group != "Not_Clustered") %>%
        dplyr::select(sample, all_of(paste0("drug_", drugs_for_heatmap))) %>%
        tibble::column_to_rownames("sample")
      
      # Rename columns to clean drug names for temp matrix (drugs are currently columns)
      colnames(heatmap_data_raw_temp) <- gsub("^drug_", "", colnames(heatmap_data_raw_temp))
      
      # Ensure order of samples (rows for temp matrix) matches annotation for samples
      heatmap_data_raw_temp <- heatmap_data_raw_temp[samples_in_cancer_type$sample, , drop = FALSE]
      
      # Convert to matrix and TRANSPOSE for desired orientation (Drugs as Rows, Samples as Columns)
      heatmap_matrix <- t(as.matrix(heatmap_data_raw_temp))
      
      # --- Check for finite values and skip if none ---
      matrix_finite_values <- heatmap_matrix[!is.na(heatmap_matrix) & is.finite(heatmap_matrix)]
      
      if (length(matrix_finite_values) == 0) {
        message(paste0("    No finite Z-score values found in heatmap matrix for ", current_cancer_type, ". Skipping heatmap."))
        next # Skip to next cancer type if no valid data
      }
      
      max_abs_z <- max(abs(range(matrix_finite_values)))
      
      if (!is.finite(max_abs_z) || max_abs_z == 0) {
        message(paste0("    Calculated max_abs_z is not finite or is zero for ", current_cancer_type, ". Skipping heatmap."))
        next
      }
      # --- End check for finite values ---
      
      color_breaks <- seq(-max_abs_z, max_abs_z, length.out = 100)
      heatmap_colors <- colorRampPalette(c("blue", "white", "red"))(length(color_breaks))
      
      # --- CORRECTED ANNOTATION SETUP for Samples as COLUMNS ---
      # Annotation for columns (samples)
      column_annotation <- data.frame(
        row.names = samples_in_cancer_type$sample, # Sample IDs are now row names of this annotation DF
        Methylation_Profile_Group = samples_in_cancer_type$Methylation_Profile_Group
      )
      
      # Define colors for annotation (use all groups from final_merged_data for consistent coloring)
      unique_groups_all_cancer <- unique(final_merged_data$Methylation_Profile_Group)
      
      if (length(unique_groups_all_cancer) == 1) {
        group_colors_palette <- c("grey")
      } else if (length(unique_groups_all_cancer) == 2) {
        group_colors_palette <- c("steelblue", "darkred")
      } else if (length(unique_groups_all_cancer) <= 8) {
        group_colors_palette <- RColorBrewer::brewer.pal(length(unique_groups_all_cancer), "Set1")
      } else {
        group_colors_palette <- viridisLite::viridis(length(unique_groups_all_cancer))
      }
      group_colors <- setNames(group_colors_palette, unique_groups_all_cancer)
      
      annotation_colors <- list(
        Methylation_Profile_Group = group_colors
      )
      
      # annotation_row is for drugs, currently no drug metadata, so it's omitted
      # --- END CORRECTED ANNOTATION SETUP ---
      
      # Cleaned cancer type name for filename and plot title (using the helper)
      clean_cancer_type_for_filename <- clean_name_for_path_extended(current_cancer_type, max_len = 50)
      
      heatmap_title <- paste0("Drug Sensitivity Z-Scores for ", current_cancer_type)
      
      # --- CALCULATE GAPS BETWEEN METHYLATION GROUPS (now for columns) ---
      sample_order_in_matrix <- colnames(heatmap_matrix) # Columns are samples
      
      ordered_groups_for_gaps <- samples_in_cancer_type %>%
        dplyr::filter(sample %in% sample_order_in_matrix) %>%
        dplyr::arrange(match(sample, sample_order_in_matrix)) %>%
        dplyr::pull(Methylation_Profile_Group)
      
      group_change_indices_cols <- which(diff(as.numeric(factor(ordered_groups_for_gaps))) != 0)
      gaps_cols_for_heatmap <- group_change_indices_cols
      # --- END GAPS CALCULATION ---
      
      # Saved heatmap dimensions
      heatmap_width <- 18 # inches - Increased
      heatmap_height <- 16 # inches - Increased
      
      heatmap_filename_tiff <- paste0("Drug_Sensitivity_Heatmap_SamplesAsCols_", clean_cancer_type_for_filename, ".tiff")
      heatmap_filename_jpg <- paste0("Drug_Sensitivity_Heatmap_SamplesAsCols_", clean_cancer_type_for_filename, ".jpg")
      
      tryCatch({
        # TIFF
        tiff(file.path(heatmap_plots_dir, heatmap_filename_tiff), width = heatmap_width, height = heatmap_height, units = "in", res = 300, compression = "lzw")
        pheatmap::pheatmap(
          heatmap_matrix,
          cluster_rows = TRUE,  # Cluster drugs (rows)
          cluster_cols = FALSE, # Keep samples ordered by Methylation Group
          show_colnames = FALSE, # Hide sample names (rely on annotation)
          show_rownames = TRUE, # Show drug names
          fontsize_row = 7,       # Font size for drug names, adjust as needed
          annotation_col = column_annotation, # Annotation for samples (columns)
          # annotation_row = NULL, # No drug annotation for now, if you have it, define it here
          annotation_colors = annotation_colors,
          main = heatmap_title,
          color = heatmap_colors,
          breaks = color_breaks,
          na_col = "grey", # Color for missing values
          fontsize = 8,
          gaps_col = gaps_cols_for_heatmap,
          border_color = "lightgrey",
          treeheight_row = 50 # Adjust drug dendrogram height
        )
        dev.off()
        message(paste0("      Saved TIFF heatmap for '", current_cancer_type, "': ", file.path(heatmap_plots_dir, heatmap_filename_tiff)))
        
        # JPG
        jpeg(file.path(heatmap_plots_dir, heatmap_filename_jpg), width = heatmap_width, height = heatmap_height, units = "in", res = 300)
        pheatmap::pheatmap(
          heatmap_matrix,
          cluster_rows = TRUE,
          cluster_cols = FALSE,
          show_colnames = FALSE,
          show_rownames = TRUE,
          fontsize_row = 7,
          annotation_col = column_annotation,
          annotation_colors = annotation_colors,
          main = heatmap_title,
          color = heatmap_colors,
          breaks = color_breaks,
          na_col = "grey",
          fontsize = 8,
          gaps_col = gaps_cols_for_heatmap,
          border_color = "lightgrey",
          treeheight_row = 50
        )
        dev.off()
        message(paste0("      Saved JPG heatmap for '", current_cancer_type, "': ", file.path(heatmap_plots_dir, heatmap_filename_jpg)))
        
        
      }, error = function(e) {
        message(paste0("      Error generating heatmap for ", current_cancer_type, ": ", e$message))
      })
    }
    message("\n--- Comprehensive Drug Sensitivity Heatmaps Complete ---")
    
  } # End of check for eligible_ranking_cancer_types
} # End of check for drug_cols_for_ranking


if (length(all_drug_rankings_list) > 0) {
  # Combine all individual drug ranking dataframes into a single dataframe
  all_combined_drug_rankings <- do.call(rbind, all_drug_rankings_list) %>%
    dplyr::filter(!is.na(Drug)) # Ensure drug names are not NA
  
  # Generate the 'drugs_of_interest' list for Section 8
  # We want drugs that are 'specific' (Is_Specific = TRUE)
  # and then rank them by their adjusted specificity p-value and median Z-score in the target group.
  drugs_of_interest <- all_combined_drug_rankings %>%
    dplyr::filter(Is_Specific == TRUE) %>% # Keep only drugs identified as specific to a group
    dplyr::arrange(Adjusted_P_value_Specificity, Median_Z_Score_Target) %>% # Sort by adjusted p-value (lowest first), then by Z-score (lowest first)
    dplyr::pull(Drug) %>% # Extract the cleaned drug names
    unique() %>% # Get unique drug names
    head(30) # Select the top N unique drugs (e.g., 30, you can change this to 15 or another number)
  
  if (length(drugs_of_interest) == 0) {
    message("\nWARNING: No drugs were identified as 'specific' (Adjusted_P_value_Specificity < 0.05).")
    message("Falling back to top 30 drugs ranked by overall median Z-score (lowest sensitivity).")
    # Fallback if no specific drugs are found
    drugs_of_interest <- all_combined_drug_rankings %>%
      dplyr::arrange(Median_Z_Score) %>% # Sort by median Z-score across all groups (lower is better)
      dplyr::pull(Drug) %>%
      unique() %>%
      head(30) # Take the top 30 by general sensitivity
  }
  
  if (length(drugs_of_interest) == 0) {
    message("WARNING: No drugs could be identified for 'drugs_of_interest' after all attempts. Setting a default placeholder list.")
    # Final fallback to a hardcoded list if nothing works
    drugs_of_interest <- c("Delanzomib (CEP-18770)", "Bortezomib", "Puromycin 2HCl", "Quisinostat (JNJ-26481585) 2HCl", "Epirubicin HCl", "YM155 (Sepantronium Bromide)", "Ganetespib (STA-9090)", "Onalespib (AT13387)", "Docetaxel Trihydrate", "Digoxin", "Sodium sulfadiazine", "Prazosin HCl", "Patupilone (EPO906, Epothilone B)", "Flavopiridol (Alvocidib)", "Bisoprolol fumarate", "Ixazomib (MLN2238)", "Idramantone", "Fosbretabulin (Combretastatin A4 Phosphate (CA4P)) Disodium", "Panobinostat (LBH589)", "Gemcitabine", "Vinblastine sulfate", "Selinexor (KPT-330)", "Vinorelbine Tartrate", "Uprosertib (GSK2141795)", "Rigosertib (ON-01910)", "Omipalisib (GSK2126458, GSK458)", "Doxorubicin (Adriamycin) HCl", "Dinaciclib (SCH727965)", "Gemcitabine HCl", "Daunorubicin HCl")
  } else {
    message(paste0("\nSuccessfully generated 'drugs_of_interest' list (top ", length(drugs_of_interest), " specific drugs):"))
    print(drugs_of_interest)
  }
  
} else {
  message("WARNING: 'all_drug_rankings_list' is empty. No drug ranking data available from Section 6.5 to determine 'drugs_of_interest'. Using a default placeholder list.")
  drugs_of_interest <- c("Delanzomib (CEP-18770)", "Bortezomib", "Puromycin 2HCl", "Quisinostat (JNJ-26481585) 2HCl", "Epirubicin HCl", "YM155 (Sepantronium Bromide)", "Ganetespib (STA-9090)", "Onalespib (AT13387)", "Docetaxel Trihydrate", "Digoxin", "Sodium sulfadiazine", "Prazosin HCl", "Patupilone (EPO906, Epothilone B)", "Flavopiridol (Alvocidib)", "Bisoprolol fumarate", "Ixazomib (MLN2238)", "Idramantone", "Fosbretabulin (Combretastatin A4 Phosphate (CA4P)) Disodium", "Panobinostat (LBH589)", "Gemcitabine", "Vinblastine sulfate", "Selinexor (KPT-330)", "Vinorelbine Tartrate", "Uprosertib (GSK2141795)", "Rigosertib (ON-01910)", "Omipalisib (GSK2126458, GSK458)", "Doxorubicin (Adriamycin) HCl", "Dinaciclib (SCH727965)", "Gemcitabine HCl", "Daunorubicin HCl")
}

message("\n--- Drug Ranking by Methylation Profile Group Complete ---")


################################################################################
########## Section 8: Drug Target Expression and Correlation Analysis ##########
################################################################################

message("\n--- Section 8: Drug Target Expression and Correlation Analysis ---")

# Ensure top-level output directory for Section 8 results exists
section8_output_dir <- file.path(output_dir, "Drug_Target_Analysis")
if (!dir.exists(section8_output_dir)) {
  dir.create(section8_output_dir, recursive = TRUE)
  message(paste0("Created Drug Target Analysis directory: ", section8_output_dir))
}

# --- Sub-section 8.1: Drug Target Gene Expression by Methylation Profile Group ---
message("\n--- 8.1: Analyzing Drug Target Gene Expression by Methylation Profile Group ---")

# --- PRE-FLIGHT CHECK: Ensure gene_symbol_map_df is ready ---
# This dataframe is crucial for mapping gene IDs to gene symbols for plotting.
# It should be generated in Section 6 (Differential Gene Expression Analysis).
skip_section_8_analysis <- FALSE
if (!exists("gene_symbol_map_df") || !is.data.frame(gene_symbol_map_df) ||
    !"geneid" %in% colnames(gene_symbol_map_df) || !"gene" %in% colnames(gene_symbol_map_df)) {
  message("SKIPPING Section 8.1 and 8.2: 'gene_symbol_map_df' is missing, not a data frame, or does not contain 'geneid' and/or 'gene' columns.")
  message("Please ensure Section 6 (Differential Gene Expression Analysis) ran successfully and created 'gene_symbol_map_df' with the expected columns.")
  skip_section_8_analysis <- TRUE
} else {
  message("Pre-check: 'gene_symbol_map_df' exists and contains 'geneid' and 'gene' columns. Proceeding with Section 8.")
}

if (!skip_section_8_analysis) { # Only proceed if the pre-check passes
  
  # IMPORTANT: Define your list of drugs of interest here.
  # This list should ideally come from your top-ranked drugs identified in Section 5
  # (e.g., from `differential_drug_sensitivity_results_df`).
  # The names here should precisely match the 'drug_name' column from your original drug data.
  if (!exists("drugs_of_interest") || length(drugs_of_interest) == 0) {
    # Placeholder if drugs_of_interest isn't already defined or is empty.
    # ***YOU SHOULD REPLACE THESE WITH YOUR ACTUAL TOP DRUGS.***
    drugs_of_interest <- c(
      "Delanzomib (CEP-18770)",
      "Bortezomib",
      "Puromycin 2HCl",
      "Quisinostat (JNJ-26481585) 2HCl",
      "Epirubicin HCl",
      "YM155 (Sepantronium Bromide)",
      "Ganetespib (STA-9090)",
      "Onalespib (AT13387)",
      "Docetaxel Trihydrate",
      "Digoxin",
      "Sodium sulfadiazine",
      "Prazosin HCl",
      "Patupilone (EPO906, Epothilone B)",
      "Flavopiridol (Alvocidib)",
      "Bisoprolol fumarate",
      "Ixazomib (MLN8237)",
      "Idramantone",
      "Fosbretabulin (Combretastatin A4 Phosphate (CA4P)) Disodium",
      "Panobinostat (LBH589)",
      "Gemcitabine",
      "Vinblastine sulfate",
      "Selinexor (KPT-330)",
      "Vinorelbine Tartrate",
      "Uprosertib (GSK2141795)",
      "Rigosertib (ON-01910)",
      "Omipalisib (GSK2126458, GSK458)",
      "Doxorubicin (Adriamycin) HCl",
      "Dinaciclib (SCH727965)",
      "Gemcitabine HCl",
      "Daunorubicin HCl"
    )
    message(paste0("WARNING: 'drugs_of_interest' not previously defined or empty. Using placeholder list: ", paste(drugs_of_interest, collapse = ", ")))
    message("Please update 'drugs_of_interest' in your script based on your Section 5 results for meaningful analysis.")
  }
  
  # Filter drug_target_map_df for drugs of interest
  # 'targets_split' is already a list-column from the previous pre-processing step
  targets_for_analysis <- drug_target_map_df %>%
    dplyr::filter(drug_name %in% drugs_of_interest) %>%
    dplyr::ungroup() # Ensure no grouping remains from previous operations
  
  if (nrow(targets_for_analysis) == 0) {
    message("No targets found in 'drug_target_map_df' for the specified 'drugs_of_interest'. Skipping drug target expression and correlation analysis (8.1 and 8.2).")
  } else {
    message(paste0("Found targets for ", nrow(targets_for_analysis), " of the specified drugs of interest."))
    
    # Loop through each eligible cancer type (same as used in DE analysis)
    for (current_cancer_type in de_eligible_cancer_types) {
      message(paste0("\n  Analyzing drug target data for: ", current_cancer_type))
      
      # --- Create specific output directory for this cancer type ---
      clean_cancer_type <- gsub("[^A-Za-z0-9_]", "_", current_cancer_type)
      # Shorten cancer type name if it's very long
      clean_cancer_type <- substr(clean_cancer_type, 1, 30) # Limit to first 30 chars
      
      cancer_type_output_subdir <- file.path(section8_output_dir, clean_cancer_type)
      if (!dir.exists(cancer_type_output_subdir)) {
        dir.create(cancer_type_output_subdir, recursive = TRUE)
        message(paste0("    Created specific output directory for ", current_cancer_type, ": ", cancer_type_output_subdir))
      }
      
      # Filter clinical data for the current cancer type and prepare for joining
      current_clinical_for_expr <- clinical_data_merged %>%
        dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
        dplyr::select(sample, Methylation_Profile_Group) %>%
        drop_na(Methylation_Profile_Group) %>%
        dplyr::filter(Methylation_Profile_Group != "Not_Clustered")
      
      if (nrow(current_clinical_for_expr) == 0) {
        message(paste0("    No eligible samples for ", current_cancer_type, ". Skipping."))
        next
      }
      
      # Ensure there are at least two groups with 3 samples each for plotting
      group_counts_expr <- current_clinical_for_expr %>%
        dplyr::count(Methylation_Profile_Group) %>%
        dplyr::filter(n >= 3) # At least 3 samples per group
      
      if (nrow(group_counts_expr) < 2) {
        message(paste0("    Skipping ", current_cancer_type, ": Not enough methylation groups (or samples per group) for target expression plotting and correlation."))
        next
      }
      
      # Get the list of samples that meet the criteria
      eligible_samples_for_expr <- current_clinical_for_expr %>%
        dplyr::filter(Methylation_Profile_Group %in% group_counts_expr$Methylation_Profile_Group) %>%
        dplyr::pull(sample)
      
      if (length(eligible_samples_for_expr) == 0) {
        message(paste0("    No eligible samples remaining for ", current_cancer_type, ". Skipping."))
        next
      }
      
      # Join RNA-seq data with clinical data for expression analysis
      current_rnaseq_long_annotated <- rnaseq_data %>%
        dplyr::filter(sample %in% eligible_samples_for_expr) %>%
        dplyr::left_join(current_clinical_for_expr, by = "sample") %>%
        dplyr::left_join(gene_symbol_map_df %>% dplyr::select(geneid, gene), by = "geneid") %>%
        dplyr::rename(gene = gene.y) %>%
        dplyr::select(-gene.x, -chr, -length)
      
      if (nrow(current_rnaseq_long_annotated) == 0) {
        message(paste0("    No RNA-seq data available for eligible samples in ", current_cancer_type, ". Skipping."))
        next
      }
      
      current_rnaseq_long_annotated <- current_rnaseq_long_annotated %>%
        drop_na(expression_value, Methylation_Profile_Group, gene) %>%
        dplyr::filter(gene != "")
      
      if (nrow(current_rnaseq_long_annotated) == 0) {
        message(paste0("    No RNA-seq data available for eligible samples after NA/empty gene filtering in ", current_cancer_type, ". Skipping."))
        next
      }
      
      # --- 8.1 (continued): Drug Target Gene Expression by Methylation Profile Group ---
      message(paste0("\n    8.1 Plotting target expression for ", current_cancer_type))
      
      # Loop through each drug (and its targets) in the filtered list
      for (i in 1:nrow(targets_for_analysis)) {
        drug_name <- targets_for_analysis$drug_name[i]
        target_genes <- targets_for_analysis$targets_split[[i]]
        
        if (length(target_genes) == 0) {
          message(paste0("      No valid target genes found for drug '", drug_name, "'. Skipping."))
          next
        }
        
        # Filter expression data for these specific target genes
        target_expr_data <- current_rnaseq_long_annotated %>%
          dplyr::filter(gene %in% target_genes)
        
        if (nrow(target_expr_data) == 0) {
          message(paste0("      No expression data found for targets of '", drug_name, "' in ", current_cancer_type, ". Skipping."))
          next
        }
        
        message(paste0("      Analyzing targets for drug: ", drug_name, " (Targets: ", paste(target_genes, collapse = ", "), ")"))
        
        # Plotting expression of target genes across methylation groups
        plot_title <- paste0(current_cancer_type, ": ", drug_name, " Target Gene(s) Expression\n(Target: ", paste(target_genes, collapse = ", "), ")")
        
        # Clean drug_name for filename and shorten it aggressively
        clean_drug_name_for_file <- substr(gsub("[^A-Za-z0-9_]", "_", drug_name), 1, 25) # More aggressive limit: 25 chars
        
        # Generate a unique hash for this drug-target combination (before truncation)
        # This ensures uniqueness even if names truncate to be identical
        unique_combo_hash <- substr(digest::digest(paste0(drug_name, paste(target_genes, collapse = "_")), algo="md5", serialize=FALSE), 1, 8)
        
        # --- IMPROVED FILENAME GENERATION FOR TARGET GENES (more aggressive) ---
        # If multiple targets, concatenate first few, then append 'X_Targs' and hash
        if (length(target_genes) > 1) {
          # Take only the first 3 genes for summary in the filename
          genes_part <- paste(head(target_genes, 3), collapse = "_")
          # Ensure genes_part is also cleaned and potentially truncated
          genes_part <- substr(gsub("[^A-Za-z0-9_]", "_", genes_part), 1, 20) # Max 20 chars for summarized genes
          clean_target_genes_for_file <- paste0(genes_part, "_", length(target_genes), "Targs")
        } else {
          # If only one target gene, use its cleaned name (more aggressive limit)
          clean_target_genes_for_file <- substr(gsub("[^A-Za-z0-9_]", "_", target_genes[1]), 1, 15) # Max 15 chars for single gene
        }
        # --- END IMPROVED FILENAME GENERATION ---
        
        # Final base filename construction with a unique hash at the end
        # This should be compact and unique, aiming for total filename part <= 80-90 chars
        base_filename <- paste0("Target_Expr_", clean_drug_name_for_file, "_", clean_target_genes_for_file, "_", unique_combo_hash)
        # Apply a final hard limit to the entire base_filename to ensure it fits with the path
        base_filename <- substr(base_filename, 1, 80) # Keep filename part to max 80 chars
        
        # Use ggplot2 for boxplots
        p <- ggplot(target_expr_data, aes(x = Methylation_Profile_Group, y = expression_value, fill = Methylation_Profile_Group)) +
          geom_boxplot(outlier.shape = NA) + # Hide outliers to show geom_jitter better
          geom_jitter(width = 0.2, alpha = 0.6) + # Add individual data points
          facet_wrap(~gene, scales = "free_y") + # If multiple targets, facet by gene
          labs(title = plot_title,
               x = "Methylation Profile Group",
               y = "Gene Expression (logCPM)") +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5, face = "bold"),
                axis.text.x = element_text(angle = 45, hjust = 1),
                legend.position = "none")
        
        # Save plots in TIFF and JPG formats - ENSURE FILE EXTENSION IS ADDED
        # Using file.path correctly adds directory separators.
        # paste0(base_filename, ".tiff") ensures the extension is always appended.
        ggsave(file.path(cancer_type_output_subdir, paste0(base_filename, ".tiff")), plot = p, width = 10, height = 7, units = "in", dpi = 300, device = "tiff")
        message(paste0("      Saved target gene expression plot (TIFF) to: ", file.path(cancer_type_output_subdir, paste0(base_filename, ".tiff"))))
        ggsave(file.path(cancer_type_output_subdir, paste0(base_filename, ".jpg")), plot = p, width = 10, height = 7, units = "in", dpi = 300, device = "jpeg")
        message(paste0("      Saved target gene expression plot (JPG) to: ", file.path(cancer_type_output_subdir, paste0(base_filename, ".jpg"))))
      } # End of drug targets loop
      
      # --- Sub-section 8.2: Correlation Analysis Between Gene Expression and Drug Sensitivity (Per Cancer Type) ---
      message(paste0("\n    8.2 Performing Correlation Analysis for ", current_cancer_type))
      
      # Combine all target genes from the selected drugs of interest
      all_target_genes_list_for_corr <- unique(unlist(targets_for_analysis$targets_split))
      
      if (length(all_target_genes_list_for_corr) == 0) {
        message("    No target genes identified for correlation analysis in this cancer type. Skipping.")
        next # Move to next cancer type if no targets
      }
      
      message(paste0("    Preparing data for correlation analysis with ", length(all_target_genes_list_for_corr), " unique target gene(s)."))
      
      # Pivot RNA-seq data to wide format for correlation, keeping only target genes
      gene_expr_wide_for_corr <- current_rnaseq_long_annotated %>%
        dplyr::filter(gene %in% all_target_genes_list_for_corr) %>% # Filter for target genes only
        dplyr::select(sample, gene, expression_value) %>%
        # FIX: Changed 'values =' to 'values_from =' for tidyr::pivot_wider
        tidyr::pivot_wider(names_from = gene, values_from = expression_value) %>%
        tibble::column_to_rownames("sample")
      
      # Filter final_merged_data for the current cancer type and eligible samples
      # NOTE: Based on your str() output, final_merged_data seems to already be in a wide format
      # (drugs as columns, Z-scores as values). We will adapt the code to this structure.
      drug_sensitivity_data_current_cancer_filtered <- final_merged_data %>%
        dplyr::filter(sample %in% eligible_samples_for_expr) %>%
        dplyr::filter(cancer_type_fullname == current_cancer_type)
      
      common_samples_for_corr <- intersect(rownames(gene_expr_wide_for_corr), drug_sensitivity_data_current_cancer_filtered$sample)
      
      if (length(common_samples_for_corr) < 5) { # Need at least a few samples for meaningful correlation
        message(paste0("    Too few common samples (", length(common_samples_for_corr), ") for correlation analysis in ", current_cancer_type, ". Skipping."))
        next # Move to next cancer type
      } else {
        message(paste0("    Performing correlations on ", length(common_samples_for_corr), " common samples for ", current_cancer_type, "."))
        
        # --- Debugging: Structure of drug_sensitivity_data_current_cancer_filtered ---
        message("    Debugging: Structure of 'drug_sensitivity_data_current_cancer_filtered':")
        print(str(drug_sensitivity_data_current_cancer_filtered))
        
        # --- IMPORTANT ADAPTATION FOR WIDE DRUG SENSITIVITY DATA ---
        # Instead of pivoting, we need to identify the drug columns directly.
        # Your 'str()' output shows drug columns are prefixed with 'drug_'.
        drug_cols_in_data <- colnames(drug_sensitivity_data_current_cancer_filtered)[grepl("^drug_", colnames(drug_sensitivity_data_current_cancer_filtered))]
        
        # Extract actual drug names from these columns by removing the "drug_" prefix
        # This creates a mapping from column name in data to the "clean" drug name we're interested in
        actual_drug_names_from_cols <- gsub("^drug_", "", drug_cols_in_data)
        
        # Filter for only those drugs that are in our 'drugs_of_interest' list
        # We need to map the 'drugs_of_interest' back to the column names in the data.
        # Create a reverse map: drug_name -> column_name
        drug_name_to_col_map <- setNames(drug_cols_in_data, actual_drug_names_from_cols)
        
        # Identify which of our 'drugs_of_interest' have corresponding columns in the data
        drugs_present_as_columns <- intersect(drugs_of_interest, actual_drug_names_from_cols)
        
        if (length(drugs_present_as_columns) == 0) {
          message(paste0("    WARNING: None of the 'drugs_of_interest' (", paste(drugs_of_interest, collapse=", "), ") have corresponding columns in the drug sensitivity data for ", current_cancer_type, ". Skipping correlation."))
          next # Skip to the next cancer type
        } else if (length(drugs_present_as_columns) < length(drugs_of_interest)) {
          missing_drugs <- setdiff(drugs_of_interest, drugs_present_as_columns)
          message(paste0("    INFO: Some 'drugs_of_interest' were not found as columns for ", current_cancer_type, " (e.g., ", paste(head(missing_drugs, 3), collapse=", "), ifelse(length(missing_drugs) > 3, "...", ""), "). Proceeding with available drugs."))
        }
        
        # Select only the sample column and the relevant drug columns
        drug_sensitivity_wide_for_corr <- drug_sensitivity_data_current_cancer_filtered %>%
          dplyr::select(sample, all_of(drug_name_to_col_map[drugs_present_as_columns])) %>%
          tibble::column_to_rownames("sample") %>%
          dplyr::arrange(match(rownames(.), common_samples_for_corr)) # Align samples
        
        # Rename the columns back to the "clean" drug names for easier use
        colnames(drug_sensitivity_wide_for_corr) <- gsub("^drug_", "", colnames(drug_sensitivity_wide_for_corr))
        
        # --- Debugging: Check for column names in the *processed* pivoted data ---
        message(paste0("    Processed drug sensitivity data columns for ", current_cancer_type, " (first 5):"))
        print(head(colnames(drug_sensitivity_wide_for_corr), 5))
        
        # Initialize a list to store correlation results for this cancer type
        correlation_results_list_per_cancer <- list()
        plot_count_corr <- 0 # To limit plots if too many (e.g., max 20 per cancer type)
        
        # Loop through each drug-target pair for correlation
        # Now, we only iterate through the drugs that were actually found as columns
        targets_for_correlation_loop <- targets_for_analysis %>%
          dplyr::filter(drug_name %in% drugs_present_as_columns) # Filter by drugs actually present
        
        if (nrow(targets_for_correlation_loop) == 0) {
          message(paste0("    No drug-target pairs remaining after filtering for present drug sensitivity data in ", current_cancer_type, ". Skipping correlation loop."))
          next
        }
        
        for (i in 1:nrow(targets_for_correlation_loop)) {
          # FIX: Reference targets_for_correlation_loop directly for current_drug_name and current_target_genes
          current_drug_name <- targets_for_correlation_loop$drug_name[i]
          current_target_genes <- targets_for_correlation_loop$targets_split[[i]]
          
          for (target_gene in current_target_genes) {
            # Check if both gene expression and drug sensitivity data are available as columns
            if (!target_gene %in% colnames(gene_expr_wide_for_corr)) {
              message(paste0("      Gene '", target_gene, "' not found in expression data for ", current_cancer_type, ". Skipping correlation for this pair."))
              next
            }
            if (!current_drug_name %in% colnames(drug_sensitivity_wide_for_corr)) {
              # This check is still valid, as `current_drug_name` should now match column names directly
              message(paste0("      Drug '", current_drug_name, "' not found in sensitivity data for ", current_cancer_type, ". Skipping correlation for this pair."))
              next
            }
            
            # Get gene expression and drug sensitivity for the pair
            gene_values <- gene_expr_wide_for_corr[[target_gene]]
            drug_values <- drug_sensitivity_wide_for_corr[[current_drug_name]]
            
            # Subset to common samples first
            gene_values_subset <- gene_values[common_samples_for_corr]
            drug_values_subset <- drug_values[common_samples_for_corr]
            
            # Debugging step: Check NAs before combining and dropping
            na_gene_count <- sum(is.na(gene_values_subset))
            na_drug_count <- sum(is.na(drug_values_subset))
            total_samples_before_drop <- length(gene_values_subset) # Should be length(common_samples_for_corr)
            
            message(paste0("        Debug: '", target_gene, "' (NA count: ", na_gene_count, "), '", current_drug_name, "' (NA count: ", na_drug_count, ") for ", total_samples_before_drop, " common samples."))
            
            
            # Remove NAs from both and align samples
            combined_data_for_corr <- data.frame(
              sample = common_samples_for_corr, # Keep sample names for inspection
              gene_expr = gene_values_subset,
              drug_sens = drug_values_subset
            ) %>% drop_na()
            
            if (nrow(combined_data_for_corr) < 5) { # Need at least 5 data points for meaningful correlation
              message(paste0("        Too few valid data points (", nrow(combined_data_for_corr), ") for correlation between ", target_gene, " expression and ", current_drug_name, " sensitivity in ", current_cancer_type, ". Skipping."))
              next
            }
            
            # Perform Spearman correlation (robust to non-normal distributions and outliers)
            correlation_test <- cor.test(combined_data_for_corr$gene_expr, combined_data_for_corr$drug_sens, method = "spearman")
            
            correlation_results_list_per_cancer[[length(correlation_results_list_per_cancer) + 1]] <- data.frame(
              cancer_type = current_cancer_type, # Add cancer type to results
              drug_name = current_drug_name,
              gene_symbol = target_gene,
              correlation_coefficient = correlation_test$estimate,
              p_value = correlation_test$p.value,
              n_samples = nrow(combined_data_for_corr)
            )
            
            # Plot significant correlations (limit plots if too many for a single cancer type)
            if (correlation_test$p.value < 0.05 && plot_count_corr < 20) {
              plot_title_corr <- paste0(current_cancer_type, ": Corr: ", target_gene, " Exp vs. ", current_drug_name, " Sens\n(Rho = ", round(correlation_test$estimate, 3), ", p = ", format.pval(correlation_test$p.value, digits = 2), ")")
              
              # Clean names for filename and shorten them (more aggressive)
              clean_gene_name_for_file <- substr(gsub("[^A-Za-z0-9_]", "_", target_gene), 1, 20) # Max 20 chars
              clean_drug_name_for_file <- substr(gsub("[^A-Za-z0-9_]", "_", current_drug_name), 1, 30) # Max 30 chars
              
              # Generate a unique hash for this gene-drug correlation pair
              unique_corr_hash <- substr(digest::digest(paste0(target_gene, current_drug_name), algo="md5", serialize=FALSE), 1, 8)
              
              # Final base filename construction for correlation plots
              base_corr_filename <- paste0("Corr_", clean_gene_name_for_file, "_vs_", clean_drug_name_for_file, "_", unique_corr_hash)
              # Apply a final hard limit to the entire base_corr_filename
              base_corr_filename <- substr(base_corr_filename, 1, 80) # Keep filename part to max 80 chars
              
              plot_data <- data.frame(
                gene_expr = combined_data_for_corr$gene_expr,
                drug_sens = combined_data_for_corr$drug_sens
              )
              
              p_corr <- ggplot(plot_data, aes(x = gene_expr, y = drug_sens)) +
                geom_point(alpha = 0.6) +
                geom_smooth(method = "lm", se = FALSE, color = "blue") + # Linear regression line
                labs(title = plot_title_corr,
                     x = paste0(target_gene, " Expression (logCPM)"),
                     y = paste0(current_drug_name, " Sensitivity (Z-score)")) +
                theme_minimal() +
                theme(plot.title = element_text(hjust = 0.5, face = "bold"))
              
              # Save plots in TIFF and JPG formats - ENSURE FILE EXTENSION IS ADDED
              ggsave(file.path(cancer_type_output_subdir, paste0(base_corr_filename, ".tiff")), plot = p_corr, width = 8, height = 6, units = "in", dpi = 300, device = "tiff")
              message(paste0("        Saved correlation plot (TIFF) to: ", file.path(cancer_type_output_subdir, paste0(base_corr_filename, ".tiff"))))
              ggsave(file.path(cancer_type_output_subdir, paste0(base_corr_filename, ".jpg")), plot = p_corr, width = 8, height = 6, units = "in", dpi = 300, device = "jpeg")
              message(paste0("        Saved correlation plot (JPG) to: ", file.path(cancer_type_output_subdir, paste0(base_corr_filename, ".jpg"))))
              plot_count_corr <- plot_count_corr + 1
            }
          } # End of target gene loop
        } # End of drug loop (targets_for_correlation_loop)
        
        if (length(correlation_results_list_per_cancer) > 0) {
          correlation_results_df_per_cancer <- do.call(rbind, correlation_results_list_per_cancer)
          # Adjust p-values for multiple comparisons (Benjamini-Hochberg) for this cancer type
          correlation_results_df_per_cancer$p_value_adj <- p.adjust(correlation_results_df_per_cancer$p_value, method = "BH")
          
          corr_output_filename <- file.path(cancer_type_output_subdir, paste0(clean_cancer_type, "_Gene_Drug_Correlation_Results.csv"))
          write_csv(correlation_results_df_per_cancer, corr_output_filename)
          message(paste0("    Saved gene-drug correlation results for ", current_cancer_type, " to: ", corr_output_filename))
        } else {
          message(paste0("    No gene-drug correlations were calculated for ", current_cancer_type, " based on the provided drugs and targets."))
        }
      } # End of else (if common_samples_for_corr has enough samples)
    } # End of cancer type loop
  } # End of if targets_for_analysis has rows
} # End of if skip_section_8_analysis

# Clean up memory (optional, only remove if not needed globally later)
# rm(section8_output_dir, cancer_type_output_subdir) # Be careful not to remove if still in loop scope
gc()

###########################################################################
# R Script: Clustering Validation and Visualization Plots

############## 1. Load Libraries ##########################################
###########################################################################

# Ensure all necessary packages are installed and loaded
# If you don't have a package, install it with install.packages("packagename")
# For Bioconductor packages (e.g., if you add one later), use BiocManager::install("packagename")

library(dplyr)      # For data manipulation (e.g., filter, select, mutate, %>%)
library(ggplot2)    # For creating high-quality plots (PCA, t-SNE, UMAP)
library(tidyr)      # For tidying data (e.g., drop_na)
library(tibble)     # For advanced tibble operations (e.g., column_to_rownames)
library(cluster)    # For silhouette analysis
library(factoextra) # For fviz_nbclust (for optimal k determination, not directly used in plots but useful for clustering workflow)
library(viridisLite) # For additional color palettes
library(Rtsne)      # For t-SNE plots
library(umap)       # For UMAP plots
library(pheatmap)   # For creating sophisticated heatmaps
library(RColorBrewer) # For diverse color palettes
library(stringr)    # For string manipulation (e.g., replacing characters, truncating)

# Set global options if needed (e.g., for Rtsne reproducibility)
set.seed(42)

###########################################################################
############## 2. Define Global Parameters (Assumed from previous steps) #
###########################################################################

# IMPORTANT: These variables are assumed to be defined and populated
# from your prior data loading and processing steps.
# If they are not, you will need to define them here or ensure they are in your environment.

# Example definitions (replace with your actual data/paths):
# clinical_data_merged <- readRDS("path/to/your/clinical_data_merged.rds")
# methylation_data_wide <- readRDS("path/to/your/methylation_data_wide.rds") # Make sure this has 'sample' column
# output_dir <- "D:/Laboratorio/Pediatrico/CCMA primary multi-omics datasets/ccma datasets/20250609_METILACION/20250623_output_analysis/"
# top_n_cpgs_for_plots <- 10000 # Number of highly variable CpGs for visualization

# Define output directory for all validation plots
validation_output_dir <- file.path(output_dir, "Clustering_Validation_Plots")
if (!dir.exists(validation_output_dir)) {
  dir.create(validation_output_dir, recursive = TRUE)
  message(paste0("Created Clustering Validation directory: ", validation_output_dir))
}

###########################################################################
############## 3. Prepare Data for Plotting ###############################
###########################################################################

message("\n--- Starting Data Preparation for Plotting ---")

print(head(clinical_data_merged))

# Use 'clinical_data_merged' which holds the final cluster assignments
# Filter to include only samples that were successfully clustered (not 'Not_Clustered')
clustered_samples_info <- clinical_data_merged %>%
  dplyr::filter(Methylation_Profile_Group != "Not_Clustered") %>%
  dplyr::select(sample, Methylation_Profile_Group, cancer_type_fullname) %>%
  dplyr::distinct()

# --- DEBUGGING STEP: Inspect clustered_samples_info ---
message("\n--- DEBUGGING: Inspecting clustered_samples_info ---")
message(paste0("Number of rows in clustered_samples_info: ", nrow(clustered_samples_info)))
if (nrow(clustered_samples_info) > 0) {
  message("First 5 sample IDs in clustered_samples_info:")
  print(head(clustered_samples_info$sample, 5))
  message("Unique groups in clustered_samples_info: ")
  print(unique(clustered_samples_info$Methylation_Profile_Group))
} else {
  message("clustered_samples_info is empty. No plots will be generated.")
}
message("--- END DEBUGGING: clustered_samples_info ---\n")

if (nrow(clustered_samples_info) == 0) {
  stop("No clustered samples found after filtering 'Not_Clustered'. Exiting plotting script.")
}

# Ensure 'methylation_data_wide' is in the correct format (samples as rows, CpGs as columns, with a 'sample' ID column)
if (!exists("methylation_data_wide") || !is.data.frame(methylation_data_wide) || !"sample" %in% colnames(methylation_data_wide)) {
  stop("Error: 'methylation_data_wide' not found or not in expected format (data frame with 'sample' column).
        Please ensure 'methylation_data_wide' is correctly prepared.")
}

# First, filter methylation_data_wide to only include clustered samples, then set 'sample' as row names
methylation_data_for_transpose <- methylation_data_wide %>%
  dplyr::filter(sample %in% clustered_samples_info$sample) %>%
  tibble::column_to_rownames("sample")

# Transpose the matrix so CpGs are rows and samples are columns
methylation_matrix_transposed_full <- t(methylation_data_for_transpose) %>%
  as.data.frame() # Convert back to data frame for consistency

# Find common samples between the transposed methylation matrix and clustered info
common_samples <- intersect(colnames(methylation_matrix_transposed_full), clustered_samples_info$sample)

# Filter methylation matrix to only common samples
methylation_matrix_for_validation <- methylation_matrix_transposed_full[, common_samples, drop = FALSE]

# Filter and arrange cluster info to match the matrix column order
clustered_samples_info_filtered <- clustered_samples_info %>%
  dplyr::filter(sample %in% common_samples) %>%
  dplyr::arrange(match(sample, colnames(methylation_matrix_for_validation)))

message(paste0("Found ", ncol(methylation_matrix_for_validation), " samples for plotting across ", length(unique(clustered_samples_info_filtered$Methylation_Profile_Group)), " clusters."))


# --- Select Highly Variable CpGs (Global Calculation) ---
# This step is performed once on the full set of common samples to identify top variable CpGs.
# This subset is then used for all global and group-wise PCA, Heatmap, t-SNE, UMAP plots.
message(paste0("  Selecting top ", top_n_cpgs_for_plots, " highly variable CpGs for visualization plots."))

# Remove rows (CpGs) with any NA values before variance calculation, or CpGs with zero variance.
temp_matrix_no_na_for_var_calc <- na.omit(methylation_matrix_for_validation)
cpg_variances_all <- apply(temp_matrix_no_na_for_var_calc, 1, var, na.rm = TRUE)
cpg_variances_all <- cpg_variances_all[!is.na(cpg_variances_all) & cpg_variances_all > 0]

if (length(cpg_variances_all) == 0) {
  stop("WARNING: No variable CpGs found after NA removal for visualization. Cannot proceed with plots.")
}

num_cpgs_to_select_global <- min(top_n_cpgs_for_plots, length(cpg_variances_all))
top_cpgs_global <- names(sort(cpg_variances_all, decreasing = TRUE))[1:num_cpgs_to_select_global]

# This is the matrix subset that will be used for all PCA, Heatmap, t-SNE, UMAP
methylation_matrix_variable_cpgs_for_plots_global <- methylation_matrix_for_validation[top_cpgs_global, , drop = FALSE]

# Prepare global annotation data frame and colors for consistent use
sample_annotation_df_global <- data.frame(
  row.names = clustered_samples_info_filtered$sample,
  Methylation_Profile_Group = clustered_samples_info_filtered$Methylation_Profile_Group,
  Cancer_Type = clustered_samples_info_filtered$cancer_type_fullname
)

# Define annotation colors consistently across all plots (global scope)
unique_groups_all <- unique(clinical_data_merged$Methylation_Profile_Group)
group_colors_palette <- if (length(unique_groups_all) <= 8) {
  RColorBrewer::brewer.pal(max(3, length(unique_groups_all)), "Set1")
} else {
  viridisLite::viridis(length(unique_groups_all))
}
if ("Not_Clustered" %in% unique_groups_all) {
  group_colors_palette[match("Not_Clustered", unique_groups_all)] <- "grey" # Assign grey for 'Not_Clustered'
}
names(group_colors_palette) <- unique_groups_all

unique_cancer_types_all <- unique(clinical_data_merged$cancer_type_fullname)
cancer_type_colors_palette <- if (length(unique_cancer_types_all) > 1) {
  if (length(unique_cancer_types_all) <= 8) {
    RColorBrewer::brewer.pal(max(3, length(unique_cancer_types_all)), "Dark2")
  } else {
    viridisLite::viridis(length(unique_cancer_types_all))
  }
} else {
  # If only one cancer type, just pick a single color (e.g., from Dark2)
  setNames("darkgreen", unique_cancer_types_all[1]) # Ensure it's named for consistency
}
if (length(unique_cancer_types_all) > 0 && is.null(names(cancer_type_colors_palette))) {
  names(cancer_type_colors_palette) <- unique_cancer_types_all
}

annotation_colors_global <- list(
  Methylation_Profile_Group = group_colors_palette[names(group_colors_palette) %in% unique(clustered_samples_info_filtered$Methylation_Profile_Group)],
  Cancer_Type = cancer_type_colors_palette[names(cancer_type_colors_palette) %in% unique(clustered_samples_info_filtered$cancer_type_fullname)]
)

message("--- Finished Data Preparation for Plotting ---\n")


###########################################################################
############## 4. Global Clustering Validation Plots ######################
###########################################################################

message("\n--- Starting Global Clustering Validation Plots ---")

if (ncol(methylation_matrix_variable_cpgs_for_plots_global) < 2) {
  message("Not enough samples for global validation plots (less than 2 after filtering variable CpGs). Skipping.")
} else {
  
  # --- Global PCA Plot ---
  message("  Generating Global PCA plot for clustering validation (using top variable CpGs)...")
  # Need to remove NAs from the matrix *before* PCA if any were introduced by CpG selection
  methylation_matrix_for_global_pca <- na.omit(methylation_matrix_variable_cpgs_for_plots_global)
  
  if (nrow(methylation_matrix_for_global_pca) > 1 && ncol(methylation_matrix_for_global_pca) > 1) {
    pca_res <- prcomp(t(methylation_matrix_for_global_pca), scale. = TRUE)
    pca_data <- as.data.frame(pca_res$x)
    pca_data$sample <- rownames(pca_data)
    pca_data <- pca_data %>%
      dplyr::left_join(clustered_samples_info_filtered, by = "sample") %>%
      tidyr::drop_na(Methylation_Profile_Group) # Remove any samples that lost their group during joins
    
    if (all(c("PC1", "PC2") %in% colnames(pca_data)) && nrow(pca_data) > 0) {
      percent_var_explained <- summary(pca_res)$importance[2,] * 100
      
      pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = Methylation_Profile_Group, shape = cancer_type_fullname)) +
        geom_point(size = 3, alpha = 0.7) +
        labs(
          title = "Global PCA of Methylation Data, Colored by Cluster",
          x = paste0("PC1 (", round(percent_var_explained["PC1"], 2), "%)"),
          y = paste0("PC2 (", round(percent_var_explained["PC2"], 2), "%)")
        ) +
        scale_color_manual(values = annotation_colors_global$Methylation_Profile_Group) +
        scale_shape_manual(values = 0:(length(unique(pca_data$cancer_type_fullname)) - 1)) + # Ensure enough shapes if many types
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, face = "bold"))
      
      ggsave(file.path(validation_output_dir, "PCA_Global.tiff"), plot = pca_plot, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
      message(paste0("    Saved Global PCA plot (TIFF): ", file.path(validation_output_dir, "PCA_Global.tiff")))
      
      ggsave(file.path(validation_output_dir, "PCA_Global.jpeg"), plot = pca_plot, width = 10, height = 8, units = "in", dpi = 150)
      message(paste0("    Saved Global PCA plot (JPEG): ", file.path(validation_output_dir, "PCA_Global.jpeg")))
      
    } else {
      message("    Not enough principal components or data for Global PCA plot after filtering variable CpGs and dropping NAs.")
    }
  } else {
    message("    Not enough variable CpGs or samples for Global PCA plot after filtering.")
  }
  
  # --- Global Heatmap of Methylation Values with Cluster Annotation ---
  message(paste0("  Generating Global Heatmap (using top ", num_cpgs_to_select_global, " variable CpGs)..."))
  
  samples_to_include_in_heatmap_global <- intersect(rownames(sample_annotation_df_global), colnames(methylation_matrix_variable_cpgs_for_plots_global))
  
  if (length(samples_to_include_in_heatmap_global) < 2) {
    message("    Not enough samples to generate global heatmap. Skipping.")
  } else {
    methylation_matrix_ordered_global <- methylation_matrix_variable_cpgs_for_plots_global[, samples_to_include_in_heatmap_global, drop = FALSE]
    sample_annotation_df_heatmap_global <- sample_annotation_df_global[samples_to_include_in_heatmap_global, , drop = FALSE]
    
    # Sort samples for heatmap visualization by Methylation_Profile_Group
    sample_annotation_df_heatmap_global <- sample_annotation_df_heatmap_global %>%
      tibble::rownames_to_column("sample_id") %>%
      dplyr::arrange(Methylation_Profile_Group, sample_id) %>%
      tibble::column_to_rownames("sample_id")
    
    methylation_matrix_ordered_global <- methylation_matrix_ordered_global[, rownames(sample_annotation_df_heatmap_global), drop = FALSE]
    
    # Ensure finite values for heatmap color breaks
    matrix_values_global <- as.vector(as.matrix(methylation_matrix_ordered_global))
    matrix_values_global <- matrix_values_global[!is.na(matrix_values_global) & is.finite(matrix_values_global)]
    
    if (length(matrix_values_global) == 0) {
      message("    No finite methylation values in matrix for global heatmap. Skipping.")
    } else {
      min_val <- min(matrix_values_global, na.rm = TRUE)
      max_val <- max(matrix_values_global, na.rm = TRUE)
      
      color_breaks_heatmap <- if (max_val == min_val) {
        c(min_val - 0.1, min_val + 0.1)
      } else {
        seq(0, 1, length.out = 100)
      }
      heatmap_colors <- colorRampPalette(c("blue", "white", "red"))(length(color_breaks_heatmap))
      
      ordered_groups_for_gaps_global <- sample_annotation_df_heatmap_global[colnames(methylation_matrix_ordered_global), "Methylation_Profile_Group"]
      group_change_indices_global <- which(diff(as.numeric(factor(ordered_groups_for_gaps_global))) != 0)
      
      # Save TIFF
      heatmap_filename_tiff_global <- file.path(validation_output_dir, "Heatmap_Global.tiff")
      tryCatch({
        tiff(heatmap_filename_tiff_global, width = 12, height = 10, units = "in", res = 300, compression = "lzw")
        pheatmap::pheatmap(
          methylation_matrix_ordered_global,
          cluster_rows = TRUE,
          cluster_cols = FALSE,
          show_colnames = FALSE,
          show_rownames = FALSE,
          annotation_col = sample_annotation_df_heatmap_global,
          annotation_colors = annotation_colors_global,
          color = heatmap_colors,
          breaks = color_breaks_heatmap,
          na_col = "grey",
          main = paste0("Global Methylation Heatmap (Top ", num_cpgs_to_select_global, " Variable CpGs)"),
          gaps_col = group_change_indices_global,
          fontsize = 8,
          treeheight_col = 0
        )
        dev.off()
        message(paste0("    Saved Global Heatmap (TIFF): ", heatmap_filename_tiff_global))
      }, error = function(e) {
        message(paste0("    Error generating global heatmap (TIFF): ", e$message))
      })
      
      # Save JPEG
      heatmap_filename_jpeg_global <- file.path(validation_output_dir, "Heatmap_Global.jpeg")
      tryCatch({
        jpeg(heatmap_filename_jpeg_global, width = 12, height = 10, units = "in", res = 150, quality = 90)
        pheatmap::pheatmap(
          methylation_matrix_ordered_global,
          cluster_rows = TRUE,
          cluster_cols = FALSE,
          show_colnames = FALSE,
          show_rownames = FALSE,
          annotation_col = sample_annotation_df_heatmap_global,
          annotation_colors = annotation_colors_global,
          color = heatmap_colors,
          breaks = color_breaks_heatmap,
          na_col = "grey",
          main = paste0("Global Methylation Heatmap (Top ", num_cpgs_to_select_global, " Variable CpGs)"),
          gaps_col = group_change_indices_global,
          fontsize = 8,
          treeheight_col = 0
        )
        dev.off()
        message(paste0("    Saved Global Heatmap (JPEG): ", heatmap_filename_jpeg_global))
      }, error = function(e) {
        message(paste0("    Error generating global heatmap (JPEG): ", e$message))
      })
    }
  }
  
  # --- Global t-SNE / UMAP Plot (using variable CpGs) ---
  methylation_matrix_no_na_for_tsne_umap_global <- na.omit(methylation_matrix_variable_cpgs_for_plots_global)
  
  if (ncol(methylation_matrix_no_na_for_tsne_umap_global) > 1 && nrow(methylation_matrix_no_na_for_tsne_umap_global) > 1) {
    if (requireNamespace("Rtsne", quietly = TRUE)) {
      message("  Generating Global t-SNE plot...")
      set.seed(42) # For reproducibility
      tsne_perplexity <- min(floor((ncol(methylation_matrix_no_na_for_tsne_umap_global) - 1) / 3), 30)
      if (tsne_perplexity >= 1) {
        tsne_res <- Rtsne::Rtsne(t(methylation_matrix_no_na_for_tsne_umap_global), dims = 2,
                                 perplexity = tsne_perplexity, verbose = FALSE, is_distance = FALSE)
        tsne_data <- as.data.frame(tsne_res$Y)
        colnames(tsne_data) <- c("Dim1", "Dim2")
        tsne_data$sample <- colnames(methylation_matrix_no_na_for_tsne_umap_global)
        tsne_data <- tsne_data %>%
          dplyr::left_join(clustered_samples_info_filtered, by = "sample") %>%
          tidyr::drop_na(Methylation_Profile_Group)
        
        if (nrow(tsne_data) > 0) {
          tsne_plot <- ggplot(tsne_data, aes(x = Dim1, y = Dim2, color = Methylation_Profile_Group, shape = cancer_type_fullname)) +
            geom_point(size = 3, alpha = 0.7) +
            labs(
              title = paste0("Global t-SNE (Top ", num_cpgs_to_select_global, " Variable CpGs)"),
              x = "t-SNE Dimension 1", y = "t-SNE Dimension 2"
            ) +
            scale_color_manual(values = annotation_colors_global$Methylation_Profile_Group) +
            scale_shape_manual(values = 0:(length(unique(tsne_data$cancer_type_fullname)) - 1)) +
            theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold"))
          
          ggsave(file.path(validation_output_dir, "tSNE_Global.tiff"), plot = tsne_plot, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
          message(paste0("    Saved Global t-SNE plot (TIFF): ", file.path(validation_output_dir, "tSNE_Global.tiff")))
          
          ggsave(file.path(validation_output_dir, "tSNE_Global.jpeg"), plot = tsne_plot, width = 10, height = 8, units = "in", dpi = 150)
          message(paste0("    Saved Global t-SNE plot (JPEG): ", file.path(validation_output_dir, "tSNE_Global.jpeg")))
          
        } else { message("    No data points for Global t-SNE plot after filtering for NAs and joining cluster info.") }
      } else { message("    Perplexity for t-SNE is too low for the number of samples for Global t-SNE plot. Skipping.") }
    } else { message("    Rtsne package not available. Skipping Global t-SNE plot.") }
    
    if (requireNamespace("umap", quietly = TRUE)) {
      message("  Generating Global UMAP plot...")
      set.seed(42) # For reproducibility
      n_samples_global_umap <- ncol(methylation_matrix_no_na_for_tsne_umap_global)
      umap_n_neighbors_global <- min(n_samples_global_umap - 1, 15) # Default 15, but cap at n_samples-1
      if (umap_n_neighbors_global < 2) { # UMAP requires n_neighbors >= 2
        message("    Not enough samples for a meaningful Global UMAP plot (n_neighbors < 2). Skipping.")
      } else {
        umap_res <- umap::umap(t(methylation_matrix_no_na_for_tsne_umap_global), n_neighbors = umap_n_neighbors_global)
        umap_data <- as.data.frame(umap_res$layout)
        colnames(umap_data) <- c("Dim1", "Dim2")
        umap_data$sample <- colnames(methylation_matrix_no_na_for_tsne_umap_global)
        umap_data <- umap_data %>%
          dplyr::left_join(clustered_samples_info_filtered, by = "sample") %>%
          tidyr::drop_na(Methylation_Profile_Group)
        
        if (nrow(umap_data) > 0) {
          umap_plot <- ggplot(umap_data, aes(x = Dim1, y = Dim2, color = Methylation_Profile_Group, shape = cancer_type_fullname)) +
            geom_point(size = 3, alpha = 0.7) +
            labs(
              title = paste0("Global UMAP (Top ", num_cpgs_to_select_global, " Variable CpGs)"),
              x = "UMAP Dimension 1", y = "UMAP Dimension 2"
            ) +
            scale_color_manual(values = annotation_colors_global$Methylation_Profile_Group) +
            scale_shape_manual(values = 0:(length(unique(umap_data$cancer_type_fullname)) - 1)) +
            theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold"))
          
          ggsave(file.path(validation_output_dir, "UMAP_Global.tiff"), plot = umap_plot, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
          message(paste0("    Saved Global UMAP plot (TIFF): ", file.path(validation_output_dir, "UMAP_Global.tiff")))
          
          ggsave(file.path(validation_output_dir, "UMAP_Global.jpeg"), plot = umap_plot, width = 10, height = 8, units = "in", dpi = 150)
          message(paste0("    Saved Global UMAP plot (JPEG): ", file.path(validation_output_dir, "UMAP_Global.jpeg")))
          
        } else { message("    No data points for Global UMAP plot after filtering for NAs and joining cluster info.") }
      }
    } else { message("    umap package not available. Skipping Global UMAP plot.") }
  } else { message("    Not enough samples or CpGs without NAs for Global t-SNE/UMAP plots.") }
  
  # --- Global Silhouette Plot (uses full matrix for distance, not subsetted CpGs) ---
  message("  Generating Global Silhouette plot for clustering validation...")
  
  # Use the original methylation_matrix_for_validation (full CpGs, common samples)
  methylation_matrix_for_silhouette_global <- na.omit(methylation_matrix_for_validation)
  
  if (ncol(methylation_matrix_for_silhouette_global) > 1 && nrow(methylation_matrix_for_silhouette_global) > 1) {
    if (length(unique(clustered_samples_info_filtered$Methylation_Profile_Group)) > 1) {
      aligned_cluster_groups_df_global <- clustered_samples_info_filtered %>%
        dplyr::filter(sample %in% colnames(methylation_matrix_for_silhouette_global)) %>%
        dplyr::arrange(match(sample, colnames(methylation_matrix_for_silhouette_global)))
      
      if (nrow(aligned_cluster_groups_df_global) == ncol(methylation_matrix_for_silhouette_global)) { # Check alignment
        dist_matrix_global <- dist(t(methylation_matrix_for_silhouette_global))
        cluster_numeric_factors_global <- as.numeric(factor(aligned_cluster_groups_df_global$Methylation_Profile_Group,
                                                            levels = unique(aligned_cluster_groups_df_global$Methylation_Profile_Group)))
        
        sil_res_global <- cluster::silhouette(cluster_numeric_factors_global, dist_matrix_global)
        sil_df_global <- as.data.frame(sil_res_global[, 1:3])
        sil_df_global$cluster_numeric <- factor(sil_df_global$cluster, levels = sort(unique(sil_df_global$cluster)))
        sil_df_global$sample <- rownames(sil_df_global)
        
        # Map numeric cluster back to original group names
        cluster_name_map_global <- setNames(aligned_cluster_groups_df_global$Methylation_Profile_Group, cluster_numeric_factors_global)
        sil_df_global$Methylation_Profile_Group <- cluster_name_map_global[as.character(sil_df_global$cluster_numeric)]
        
        sil_df_global <- sil_df_global %>%
          dplyr::arrange(cluster_numeric, desc(sil_width)) %>%
          dplyr::mutate(sample_reordered = factor(sample, levels = sample)) # Reorder samples for plotting
        
        avg_sil_width_global <- mean(sil_df_global$sil_width)
        
        silhouette_plot_global <- ggplot(sil_df_global, aes(x = sample_reordered, y = sil_width, fill = Methylation_Profile_Group)) +
          geom_bar(stat = "identity") + coord_flip() +
          scale_fill_manual(values = annotation_colors_global$Methylation_Profile_Group) +
          labs(
            title = paste0("Global Silhouette Plot (Avg. Silhouette Width: ", round(avg_sil_width_global, 2), ")"),
            subtitle = "Higher silhouette width indicates better clustering", x = "Sample", y = "Silhouette Width"
          ) +
          theme_minimal() + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
                                  panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(),
                                  plot.title = element_text(hjust = 0.5, face = "bold"))
        
        ggsave(file.path(validation_output_dir, "Silhouette_Global.tiff"), plot = silhouette_plot_global, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
        message(paste0("    Saved Global Silhouette plot (TIFF): ", file.path(validation_output_dir, "Silhouette_Global.tiff")))
        
        ggsave(file.path(validation_output_dir, "Silhouette_Global.jpeg"), plot = silhouette_plot_global, width = 10, height = 8, units = "in", dpi = 150)
        message(paste0("    Saved Global Silhouette plot (JPEG): ", file.path(validation_output_dir, "Silhouette_Global.jpeg")))
        
      } else { message("    Skipping Global Silhouette plot: Mismatch in sample count after NA omission for distance calculation.") }
    } else { message("    Skipping Global Silhouette plot: Only one cluster found, or not enough samples after NA omission.") }
  } else { message("    Skipping Global Silhouette plot: Not enough samples or CpGs without NAs for distance calculation.") }
  
} # End of global plots block

message("\n--- Finished Global Clustering Validation Plots ---")

###########################################################################
############## 5. Cancer Type-wise Clustering Validation Plots (Custom) ###
###########################################################################

message("\n--- Generating Cancer Type-wise Clustering Validation Plots (by Cancer Type, showing Methylation Groups) ---")

# Get unique cancer types that have samples classified into a "Methylated" or "Unmethylated" subtype.
# This uses stringr::str_detect to correctly match the actual group names.
unique_cancer_types_for_plotting <- clinical_data_merged %>%
  dplyr::filter(stringr::str_detect(Methylation_Profile_Group, "_Methylated$|_Unmethylated$")) %>%
  dplyr::pull(cancer_type_fullname) %>%
  unique() %>%
  na.omit() %>%
  as.character()

# Helper function to clean names for directory and file names
clean_name_for_path <- function(name_to_clean) {
  cleaned_name <- stringr::str_replace_all(name_to_clean, "[[:punct:] ]+", "_")
  # Further truncate if still too long to avoid potential path issues on some OS
  if (nchar(cleaned_name) > 50) { # Keep it reasonably short
    cleaned_name <- substr(cleaned_name, 1, 50)
  }
  return(cleaned_name)
}

if (length(unique_cancer_types_for_plotting) == 0) {
  message("No eligible cancer types with 'Methylated' or 'Unmethylated' groups found for plotting. Skipping.")
} else {
  
  for (current_cancer_type in unique_cancer_types_for_plotting) {
    message(paste0("  Processing Cancer Type: ", current_cancer_type))
    
    # Create a subdirectory for each cancer type
    cancer_type_output_dir <- file.path(validation_output_dir, clean_name_for_path(current_cancer_type))
    if (!dir.exists(cancer_type_output_dir)) {
      dir.create(cancer_type_output_dir, recursive = TRUE)
      message(paste0("    Created cancer type directory: ", cancer_type_output_dir))
    }
    
    # Use the cleaned cancer type name as a short identifier for filenames
    short_filename_id <- clean_name_for_path(current_cancer_type)
    
    # Filter samples belonging to the current cancer type and are classified as Methylated/Unmethylated subtype
    # This now correctly identifies the group names using str_detect
    samples_in_current_cancer_type <- clinical_data_merged %>%
      dplyr::filter(cancer_type_fullname == current_cancer_type,
                    stringr::str_detect(Methylation_Profile_Group, "_Methylated$|_Unmethylated$")) %>%
      pull(sample)
    
    if (length(samples_in_current_cancer_type) < 2) {
      message(paste0("    Skipping plots for '", current_cancer_type, "': Not enough samples (", length(samples_in_current_cancer_type), ") with 'Methylated' or 'Unmethylated' status."))
      next # Skip to next cancer type if insufficient samples
    }
    
    # Filter the global variable CpGs matrix for samples in the current cancer type
    # This matrix contains the globally selected top_n_cpgs_for_plots
    cancer_type_methylation_matrix <- methylation_matrix_variable_cpgs_for_plots_global[, samples_in_current_cancer_type, drop = FALSE]
    
    # Prepare annotation data frame for the current cancer type's plots
    # Ensure this df only contains samples that are actually in the methylation matrix
    cancer_type_annotation_df <- clinical_data_merged %>%
      dplyr::filter(sample %in% colnames(cancer_type_methylation_matrix)) %>% # Filter using the actual matrix columns
      dplyr::select(sample, Methylation_Profile_Group, cancer_type_fullname) %>%
      tibble::column_to_rownames("sample")
    
    # Ensure local annotation colors for the current cancer type's plots
    # Filter global palettes to only include colors for methylation groups present in this specific cancer type
    methylation_groups_in_type <- unique(cancer_type_annotation_df$Methylation_Profile_Group)
    local_methylation_group_colors <- annotation_colors_global$Methylation_Profile_Group[names(annotation_colors_global$Methylation_Profile_Group) %in% methylation_groups_in_type]
    
    # The cancer_type_fullname for this loop is constant, so its color will be just one.
    # We retrieve it from the global palette.
    local_cancer_type_color_for_annotation <- annotation_colors_global$Cancer_Type[current_cancer_type]
    
    # Combine into a list for annotation_colors argument for pheatmap
    current_plot_annotation_colors <- list(
      Methylation_Profile_Group = local_methylation_group_colors
      # For plots where Cancer_Type is the primary loop, it's often not mapped as a distinct color aesthetic *within* the plot.
      # However, for pheatmap, having it explicitly can be useful for clarity if there's a legend.
      # Adding it to the list, pheatmap will only use it if 'Cancer_Type' is in annotation_col.
      # Cancer_Type = local_cancer_type_color_for_annotation # This will be a single color for this plot
    )
    
    # For pheatmap, it's important that the annotation_colors list contains entries for all columns in annotation_col.
    # Let's ensure the Cancer_Type is included here if it's going to be used as an annotation column in the heatmap.
    if ("Cancer_Type" %in% colnames(cancer_type_annotation_df) && length(local_cancer_type_color_for_annotation) > 0) {
      current_plot_annotation_colors$Cancer_Type <- local_cancer_type_color_for_annotation
    }
    
    
    # Important: Remove NAs from the matrix *before* dimensionality reduction
    # This prevents issues with PCA/t-SNE/UMAP.
    cancer_type_methylation_matrix_no_na_for_dim_red <- na.omit(cancer_type_methylation_matrix)
    
    # Check if enough data remains after NA removal for dim reduction plots
    if (ncol(cancer_type_methylation_matrix_no_na_for_dim_red) < 2 || nrow(cancer_type_methylation_matrix_no_na_for_dim_red) < 2) {
      message(paste0("    Skipping PCA, t-SNE, UMAP for '", current_cancer_type, "': Not enough non-NA samples or CpGs after subsetting."))
      # No 'next' here, as Heatmap might still be possible depending on its NA handling
    } else { # Block for PCA, t-SNE, UMAP (which need no NAs and enough dimensions)
      
      # --- Cancer Type-wise PCA Plot ---
      message(paste0("    Generating PCA plot for '", current_cancer_type, "'..."))
      pca_res_current_type <- prcomp(t(cancer_type_methylation_matrix_no_na_for_dim_red), scale. = TRUE)
      pca_data_current_type <- as.data.frame(pca_res_current_type$x)
      pca_data_current_type$sample <- rownames(pca_data_current_type)
      pca_data_current_type <- pca_data_current_type %>%
        dplyr::left_join(cancer_type_annotation_df %>% tibble::rownames_to_column("sample"), by = "sample")
      
      if (all(c("PC1", "PC2") %in% colnames(pca_data_current_type)) && nrow(pca_data_current_type) > 0) {
        percent_var_explained_current_type <- summary(pca_res_current_type)$importance[2,] * 100
        
        pca_plot_current_type <- ggplot(pca_data_current_type, aes(x = PC1, y = PC2, color = Methylation_Profile_Group)) +
          geom_point(size = 3, alpha = 0.7) +
          labs(
            title = paste0("PCA for ", current_cancer_type, "\n(Colored by Methylation Profile Group)"),
            x = paste0("PC1 (", round(percent_var_explained_current_type["PC1"], 2), "%)"),
            y = paste0("PC2 (", round(percent_var_explained_current_type["PC2"], 2), "%)")
          ) +
          scale_color_manual(values = current_plot_annotation_colors$Methylation_Profile_Group) +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5, face = "bold"))
        
        ggsave(file.path(cancer_type_output_dir, paste0("PCA_", short_filename_id, ".tiff")), plot = pca_plot_current_type, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
        message(paste0("      Saved PCA plot (TIFF): ", file.path(cancer_type_output_dir, paste0("PCA_", short_filename_id, ".tiff"))))
        
        ggsave(file.path(cancer_type_output_dir, paste0("PCA_", short_filename_id, ".jpeg")), plot = pca_plot_current_type, width = 10, height = 8, units = "in", dpi = 150)
        message(paste0("      Saved PCA plot (JPEG): ", file.path(cancer_type_output_dir, paste0("PCA_", short_filename_id, ".jpeg"))))
        
      } else { message(paste0("      Not enough components/data for PCA plot for '", current_cancer_type, "'.")) }
      
      # --- Cancer Type-wise t-SNE Plot ---
      message(paste0("    Generating t-SNE plot for '", current_cancer_type, "'..."))
      n_samples_for_tsne_umap <- ncol(cancer_type_methylation_matrix_no_na_for_dim_red)
      
      if (n_samples_for_tsne_umap >= 2) {
        tsne_perplexity_current_type <- min(floor((n_samples_for_tsne_umap - 1) / 3), 30) # Dynamic perplexity
        if (tsne_perplexity_current_type >= 1) {
          set.seed(42) # For reproducibility
          tsne_res_current_type <- Rtsne::Rtsne(t(cancer_type_methylation_matrix_no_na_for_dim_red), dims = 2,
                                                perplexity = tsne_perplexity_current_type, verbose = FALSE, is_distance = FALSE)
          tsne_data_current_type <- as.data.frame(tsne_res_current_type$Y)
          colnames(tsne_data_current_type) <- c("Dim1", "Dim2")
          tsne_data_current_type$sample <- colnames(cancer_type_methylation_matrix_no_na_for_dim_red)
          tsne_data_current_type <- tsne_data_current_type %>%
            dplyr::left_join(cancer_type_annotation_df %>% tibble::rownames_to_column("sample"), by = "sample")
          
          if (nrow(tsne_data_current_type) > 0) {
            tsne_plot_current_type <- ggplot(tsne_data_current_type, aes(x = Dim1, y = Dim2, color = Methylation_Profile_Group)) +
              geom_point(size = 3, alpha = 0.7) +
              labs(
                title = paste0("t-SNE for ", current_cancer_type, "\n(Colored by Methylation Profile Group)"),
                x = "t-SNE Dimension 1", y = "t-SNE Dimension 2"
              ) +
              scale_color_manual(values = current_plot_annotation_colors$Methylation_Profile_Group) +
              theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold"))
            
            ggsave(file.path(cancer_type_output_dir, paste0("tSNE_", short_filename_id, ".tiff")), plot = tsne_plot_current_type, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
            message(paste0("      Saved t-SNE plot (TIFF): ", file.path(cancer_type_output_dir, paste0("tSNE_", short_filename_id, ".tiff"))))
            
            ggsave(file.path(cancer_type_output_dir, paste0("tSNE_", short_filename_id, ".jpeg")), plot = tsne_plot_current_type, width = 10, height = 8, units = "in", dpi = 150)
            message(paste0("      Saved t-SNE plot (JPEG): ", file.path(cancer_type_output_dir, paste0("tSNE_", short_filename_id, ".jpeg"))))
            
          } else { message(paste0("      No data points for t-SNE plot for '", current_cancer_type, "' after filtering for NAs and joining cluster info.")) }
        } else { message(paste0("      Perplexity for t-SNE is too low for the number of samples (", n_samples_for_tsne_umap, ") for '", current_cancer_type, "'. Skipping t-SNE plot.")) }
      } else { message(paste0("    Rtsne package not available. Skipping t-SNE plot for '", current_cancer_type, "'.")) }
      
      # --- Cancer Type-wise UMAP Plot ---
      message(paste0("    Generating UMAP plot for '", current_cancer_type, "'..."))
      if (n_samples_for_tsne_umap >= 2) {
        umap_n_neighbors_current_type <- min(n_samples_for_tsne_umap - 1, 15)
        
        if (umap_n_neighbors_current_type >= 2) {
          set.seed(42) # For reproducibility
          umap_res_current_type <- umap::umap(t(cancer_type_methylation_matrix_no_na_for_dim_red), n_neighbors = umap_n_neighbors_current_type)
          umap_data_current_type <- as.data.frame(umap_res_current_type$layout)
          colnames(umap_data_current_type) <- c("Dim1", "Dim2")
          umap_data_current_type$sample <- colnames(cancer_type_methylation_matrix_no_na_for_dim_red)
          umap_data_current_type <- umap_data_current_type %>%
            dplyr::left_join(cancer_type_annotation_df %>% tibble::rownames_to_column("sample"), by = "sample")
          
          if (nrow(umap_data_current_type) > 0) {
            umap_plot_current_type <- ggplot(umap_data_current_type, aes(x = Dim1, y = Dim2, color = Methylation_Profile_Group)) +
              geom_point(size = 3, alpha = 0.7) +
              labs(
                title = paste0("UMAP for ", current_cancer_type, "\n(Colored by Methylation Profile Group)"),
                x = "UMAP Dimension 1", y = "UMAP Dimension 2"
              ) +
              scale_color_manual(values = current_plot_annotation_colors$Methylation_Profile_Group) +
              theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold"))
            
            ggsave(file.path(cancer_type_output_dir, paste0("UMAP_", short_filename_id, ".tiff")), plot = umap_plot_current_type, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
            message(paste0("      Saved UMAP plot (TIFF): ", file.path(cancer_type_output_dir, paste0("UMAP_", short_filename_id, ".tiff"))))
            
            ggsave(file.path(cancer_type_output_dir, paste0("UMAP_", short_filename_id, ".jpeg")), plot = umap_plot_current_type, width = 10, height = 8, units = "in", dpi = 150)
            message(paste0("      Saved UMAP plot (JPEG): ", file.path(cancer_type_output_dir, paste0("UMAP_", short_filename_id, ".jpeg"))))
            
          } else { message(paste0("      No data points for UMAP plot for '", current_cancer_type, "' after filtering for NAs and joining cluster info.")) }
        } else { message(paste0("      Not enough samples (", n_samples_for_tsne_umap, ") for a meaningful UMAP plot (n_neighbors < 2) for '", current_cancer_type, "'. Skipping UMAP plot.")) }
      } else { message(paste0("    umap package not available. Skipping UMAP plot for '", current_cancer_type, "'.")) }
    } # End of PCA/tSNE/UMAP block (requires >1 samples & CpGs, no NA)
    
    
    # --- Cancer Type-wise Heatmap ---
    message(paste0("    Generating Heatmap for '", current_cancer_type, "'..."))
    
    # The heatmap can handle NAs, but still ensure at least 2 samples for a meaningful heatmap.
    if (ncol(cancer_type_methylation_matrix) < 2) {
      message(paste0("      Not enough samples (", ncol(cancer_type_methylation_matrix), ") for heatmap for '", current_cancer_type, "'. Skipping."))
    } else {
      # Prepare annotation data frame for heatmap: ensure sorting by Methylation_Profile_Group for gaps
      cancer_type_annotation_df_heatmap <- cancer_type_annotation_df %>%
        tibble::rownames_to_column("sample_id") %>%
        dplyr::arrange(Methylation_Profile_Group, sample_id) %>% # Sort by Methylation_Profile_Group
        tibble::column_to_rownames("sample_id")
      
      # Order the methylation matrix columns to match the sorted annotation
      cancer_type_methylation_matrix_ordered_heatmap <- cancer_type_methylation_matrix[, rownames(cancer_type_annotation_df_heatmap), drop = FALSE]
      
      # Ensure finite values for heatmap color breaks
      matrix_values_current_type <- as.vector(as.matrix(cancer_type_methylation_matrix_ordered_heatmap))
      matrix_values_current_type <- matrix_values_current_type[!is.na(matrix_values_current_type) & is.finite(matrix_values_current_type)]
      
      if (length(matrix_values_current_type) == 0) {
        message(paste0("      No finite methylation values in matrix for heatmap for '", current_cancer_type, "'. Skipping."))
      } else {
        min_val_current_type <- min(matrix_values_current_type, na.rm = TRUE)
        max_val_current_type <- max(matrix_values_current_type, na.rm = TRUE)
        
        color_breaks_heatmap_current_type <- if (max_val_current_type == min_val_current_type) {
          c(min_val_current_type - 0.1, min_val_current_type + 0.1)
        } else {
          seq(0, 1, length.out = 100)
        }
        heatmap_colors_current_type <- colorRampPalette(c("blue", "white", "red"))(length(color_breaks_heatmap_current_type))
        
        # Define gaps based on Methylation_Profile_Group within this cancer type
        ordered_groups_for_gaps <- cancer_type_annotation_df_heatmap[colnames(cancer_type_methylation_matrix_ordered_heatmap), "Methylation_Profile_Group"]
        group_change_indices <- which(diff(as.numeric(factor(ordered_groups_for_gaps))) != 0)
        
        # Save TIFF
        tryCatch({
          tiff(file.path(cancer_type_output_dir, paste0("Heatmap_", short_filename_id, ".tiff")), width = 12, height = 10, units = "in", res = 300, compression = "lzw")
          pheatmap::pheatmap(
            cancer_type_methylation_matrix_ordered_heatmap,
            cluster_rows = TRUE, # Cluster CpGs
            cluster_cols = FALSE, # Do not cluster samples, rely on pre-sorting
            show_colnames = FALSE,
            show_rownames = FALSE,
            annotation_col = cancer_type_annotation_df_heatmap, # This dataframe includes both Methylation_Profile_Group and Cancer_Type
            annotation_colors = current_plot_annotation_colors, # This list provides colors for both
            color = heatmap_colors_current_type,
            breaks = color_breaks_heatmap_current_type,
            na_col = "grey",
            main = paste0("Methylation Heatmap for ", current_cancer_type, " (Top ", num_cpgs_to_select_global, " CpGs)"),
            gaps_col = group_change_indices, # Gaps based on Methylation_Profile_Group
            fontsize = 8,
            treeheight_col = 0 # No column tree as we are not clustering columns
          )
          dev.off()
          message(paste0("      Saved Heatmap (TIFF): ", file.path(cancer_type_output_dir, paste0("Heatmap_", short_filename_id, ".tiff"))))
        }, error = function(e) {
          message(paste0("      Error generating heatmap (TIFF) for '", current_cancer_type, "': ", e$message))
        })
        
        # Save JPEG
        tryCatch({
          jpeg(file.path(cancer_type_output_dir, paste0("Heatmap_", short_filename_id, ".jpeg")), width = 12, height = 10, units = "in", res = 150, quality = 90)
          pheatmap::pheatmap(
            cancer_type_methylation_matrix_ordered_heatmap,
            cluster_rows = TRUE,
            cluster_cols = FALSE,
            show_colnames = FALSE,
            show_rownames = FALSE,
            annotation_col = cancer_type_annotation_df_heatmap,
            annotation_colors = current_plot_annotation_colors,
            color = heatmap_colors_current_type,
            breaks = color_breaks_heatmap_current_type,
            na_col = "grey",
            main = paste0("Methylation Heatmap for ", current_cancer_type, " (Top ", num_cpgs_to_select_global, " CpGs)"),
            gaps_col = group_change_indices,
            fontsize = 8,
            treeheight_col = 0
          )
          dev.off()
          message(paste0("      Saved Heatmap (JPEG): ", file.path(cancer_type_output_dir, paste0("Heatmap_", short_filename_id, ".jpeg"))))
        }, error = function(e) {
          message(paste0("      Error generating heatmap (JPEG) for '", current_cancer_type, "': ", e$message))
        })
      }
    }
    
  } # End of loop for current_cancer_type
} # End of if length(unique_cancer_types_for_plotting) == 0

message("\n--- Finished Cancer Type-wise Clustering Validation Plots ---")


message("\n--- All clustering validation plots generated successfully! ---")

####################################################################################################

message("\n--- Generating Cancer Type-wise Clustering Validation Plots with Refined Clustering ---")

# Primero, aseguramos que la matriz global sea numérica (si no lo está)
if (!is.numeric(methylation_matrix_variable_cpgs_for_plots_global)) {
  message("Convirtiendo methylation_matrix_variable_cpgs_for_plots_global a matriz numérica...")
  # Guardamos nombres de filas y columnas
  row_names_orig <- rownames(methylation_matrix_variable_cpgs_for_plots_global)
  col_names_orig <- colnames(methylation_matrix_variable_cpgs_for_plots_global)
  
  # Convertimos forzosamente a matriz numérica
  methylation_matrix_variable_cpgs_for_plots_global <- apply(methylation_matrix_variable_cpgs_for_plots_global, 2, function(x) as.numeric(as.character(x)))
  
  # Reconstruimos la matriz para mantener dimensiones y nombres
  methylation_matrix_variable_cpgs_for_plots_global <- matrix(methylation_matrix_variable_cpgs_for_plots_global, 
                                                              nrow = length(row_names_orig), 
                                                              ncol = length(col_names_orig), 
                                                              dimnames = list(row_names_orig, col_names_orig))
  message("Conversión completa.")
}

if (length(unique_cancer_types_for_plotting) == 0) {
  message("No eligible cancer types with 'Methylated' or 'Unmethylated' groups found for plotting. Skipping.")
} else {
  for (current_cancer_type in unique_cancer_types_for_plotting) {
    message(paste0("  Processing Cancer Type: ", current_cancer_type))
    
    # Create output directory if missing
    cancer_type_output_dir <- file.path(validation_output_dir, clean_name_for_path(current_cancer_type))
    if (!dir.exists(cancer_type_output_dir)) {
      dir.create(cancer_type_output_dir, recursive = TRUE)
      message(paste0("    Created cancer type directory: ", cancer_type_output_dir))
    }
    
    short_filename_id <- clean_name_for_path(current_cancer_type)
    
    # Filter samples in current cancer type with Methylated or Unmethylated group
    samples_in_current_cancer_type <- clinical_data_merged %>%
      dplyr::filter(cancer_type_fullname == current_cancer_type,
                    stringr::str_detect(Methylation_Profile_Group, "_Methylated$|_Unmethylated$")) %>%
      pull(sample)
    
    if (length(samples_in_current_cancer_type) < 2) {
      message(paste0("    Skipping plots for '", current_cancer_type, "': Not enough samples (", length(samples_in_current_cancer_type), ") with 'Methylated' or 'Unmethylated' status."))
      next
    }
    
    # Subset methylation matrix to those samples
    cancer_type_methylation_matrix <- methylation_matrix_variable_cpgs_for_plots_global[, samples_in_current_cancer_type, drop = FALSE]
    
    # Select top variable CpGs within this cancer type
    cpg_vars <- apply(cancer_type_methylation_matrix, 1, var, na.rm = TRUE)
    top_n <- min(500, length(cpg_vars)) # Adjust top N if you want
    top_cpgs <- names(sort(cpg_vars, decreasing = TRUE))[1:top_n]
    mat_var <- cancer_type_methylation_matrix[top_cpgs, , drop = FALSE]
    
    # Impute missing values (mean per CpG)
    if (any(is.na(mat_var))) {
      for (i in seq_len(nrow(mat_var))) {
        nas <- is.na(mat_var[i, ])
        if (any(nas)) {
          mat_var[i, nas] <- mean(mat_var[i, ], na.rm = TRUE)
        }
      }
    }
    
    # Transpose for clustering: rows = samples, columns = CpGs
    mat_var_t <- t(mat_var)
    
    # Compute distance matrix and cluster samples
    dist_mat <- dist(mat_var_t, method = "euclidean")
    hc <- hclust(dist_mat, method = "ward.D2")
    clusters <- cutree(hc, k = 2) # 2 clusters: methylated vs unmethylated
    
    # Silhouette width to assess clustering quality
    library(cluster)
    sil <- silhouette(clusters, dist_mat)
    avg_sil_width <- mean(sil[, 3])
    message(paste0("    Avg silhouette width for refined clustering: ", round(avg_sil_width, 3)))
    
    # Build refined annotation dataframe
    refined_cluster_df <- data.frame(
      sample = names(clusters),
      refined_meth_cluster = factor(clusters, labels = paste0("Cluster_", 1:2))
    )
    
    # Base annotation dataframe for this cancer type (using original clinical info)
    cancer_type_annotation_df <- clinical_data_merged %>%
      dplyr::filter(sample %in% colnames(cancer_type_methylation_matrix)) %>%
      dplyr::select(sample, Methylation_Profile_Group, cancer_type_fullname) %>%
      tibble::column_to_rownames("sample")
    
    # Add refined cluster assignment to annotation df
    cancer_type_annotation_df$refined_meth_cluster <- refined_cluster_df$refined_meth_cluster[match(rownames(cancer_type_annotation_df), refined_cluster_df$sample)]
    
    # Prepare colors for refined clusters
    refined_colors <- c("Cluster_1" = "blue", "Cluster_2" = "red")
    
    # Prepare annotation colors list
    methylation_groups_in_type <- unique(cancer_type_annotation_df$Methylation_Profile_Group)
    local_methylation_group_colors <- annotation_colors_global$Methylation_Profile_Group[names(annotation_colors_global$Methylation_Profile_Group) %in% methylation_groups_in_type]
    local_cancer_type_color <- annotation_colors_global$Cancer_Type[current_cancer_type]
    
    current_plot_annotation_colors <- list(
      Methylation_Profile_Group = local_methylation_group_colors,
      refined_meth_cluster = refined_colors
    )
    if ("Cancer_Type" %in% colnames(cancer_type_annotation_df) && length(local_cancer_type_color) > 0) {
      current_plot_annotation_colors$Cancer_Type <- local_cancer_type_color
    }
    
    # Remove NAs for PCA, t-SNE, UMAP
    cancer_type_methylation_matrix_no_na <- na.omit(cancer_type_methylation_matrix)
    
    if (ncol(cancer_type_methylation_matrix_no_na) < 2 || nrow(cancer_type_methylation_matrix_no_na) < 2) {
      message(paste0("    Skipping PCA, t-SNE, UMAP for '", current_cancer_type, "': Not enough non-NA samples or CpGs after subsetting."))
    } else {
      # PCA plot colored by refined clusters
      message(paste0("    Generating PCA plot for '", current_cancer_type, "' (Refined clusters)..."))
      pca_res <- prcomp(t(cancer_type_methylation_matrix_no_na), scale. = TRUE)
      pca_data <- as.data.frame(pca_res$x)
      pca_data$sample <- rownames(pca_data)
      pca_data <- pca_data %>%
        dplyr::left_join(cancer_type_annotation_df %>% tibble::rownames_to_column("sample"), by = "sample")
      
      percent_var <- summary(pca_res)$importance[2,]
      pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = refined_meth_cluster)) +
        geom_point(size = 3, alpha = 0.7) +
        labs(
          title = paste0("PCA for ", current_cancer_type, " (Refined Clusters)"),
          x = paste0("PC1 (", round(percent_var["PC1"]*100, 2), "%)"),
          y = paste0("PC2 (", round(percent_var["PC2"]*100, 2), "%)")
        ) +
        scale_color_manual(values = refined_colors) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, face = "bold"))
      
      ggsave(file.path(cancer_type_output_dir, paste0("PCA_", short_filename_id, "_refined.tiff")), plot = pca_plot, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
      ggsave(file.path(cancer_type_output_dir, paste0("PCA_", short_filename_id, "_refined.jpeg")), plot = pca_plot, width = 10, height = 8, units = "in", dpi = 150)
      message(paste0("      Saved PCA plot with refined clusters for '", current_cancer_type, "'."))
      
      # t-SNE plot colored by refined clusters
      message(paste0("    Generating t-SNE plot for '", current_cancer_type, "' (Refined clusters)..."))
      n_samples_tsne <- ncol(cancer_type_methylation_matrix_no_na)
      tsne_perplexity <- min(floor((n_samples_tsne - 1) / 3), 30)
      if (tsne_perplexity >= 1) {
        set.seed(42)
        tsne_res <- Rtsne::Rtsne(t(cancer_type_methylation_matrix_no_na), dims = 2, perplexity = tsne_perplexity, verbose = FALSE, is_distance = FALSE)
        tsne_data <- as.data.frame(tsne_res$Y)
        colnames(tsne_data) <- c("Dim1", "Dim2")
        tsne_data$sample <- colnames(cancer_type_methylation_matrix_no_na)
        tsne_data <- tsne_data %>%
          dplyr::left_join(cancer_type_annotation_df %>% tibble::rownames_to_column("sample"), by = "sample")
        
        tsne_plot <- ggplot(tsne_data, aes(x = Dim1, y = Dim2, color = refined_meth_cluster)) +
          geom_point(size = 3, alpha = 0.7) +
          labs(title = paste0("t-SNE for ", current_cancer_type, " (Refined Clusters)"),
               x = "t-SNE Dimension 1", y = "t-SNE Dimension 2") +
          scale_color_manual(values = refined_colors) +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5, face = "bold"))
        
        ggsave(file.path(cancer_type_output_dir, paste0("tSNE_", short_filename_id, "_refined.tiff")), plot = tsne_plot, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
        ggsave(file.path(cancer_type_output_dir, paste0("tSNE_", short_filename_id, "_refined.jpeg")), plot = tsne_plot, width = 10, height = 8, units = "in", dpi = 150)
        message(paste0("      Saved t-SNE plot with refined clusters for '", current_cancer_type, "'."))
      } else {
        message(paste0("      Perplexity too low for t-SNE in '", current_cancer_type, "'. Skipping t-SNE plot."))
      }
      
      # UMAP plot colored by refined clusters
      message(paste0("    Generating UMAP plot for '", current_cancer_type, "' (Refined clusters)..."))
      if (n_samples_tsne - 1 >= 2) {
        set.seed(42)
        umap_res <- umap::umap(t(cancer_type_methylation_matrix_no_na), n_neighbors = min(n_samples_tsne - 1, 15))
        umap_data <- as.data.frame(umap_res$layout)
        colnames(umap_data) <- c("Dim1", "Dim2")
        umap_data$sample <- colnames(cancer_type_methylation_matrix_no_na)
        umap_data <- umap_data %>%
          dplyr::left_join(cancer_type_annotation_df %>% tibble::rownames_to_column("sample"), by = "sample")
        
        umap_plot <- ggplot(umap_data, aes(x = Dim1, y = Dim2, color = refined_meth_cluster)) +
          geom_point(size = 3, alpha = 0.7) +
          labs(title = paste0("UMAP for ", current_cancer_type, " (Refined Clusters)"),
               x = "UMAP Dimension 1", y = "UMAP Dimension 2") +
          scale_color_manual(values = refined_colors) +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5, face = "bold"))
        
        ggsave(file.path(cancer_type_output_dir, paste0("UMAP_", short_filename_id, "_refined.tiff")), plot = umap_plot, width = 10, height = 8, units = "in", dpi = 300, compression = "lzw")
        ggsave(file.path(cancer_type_output_dir, paste0("UMAP_", short_filename_id, "_refined.jpeg")), plot = umap_plot, width = 10, height = 8, units = "in", dpi = 150)
        message(paste0("      Saved UMAP plot with refined clusters for '", current_cancer_type, "'."))
      } else {
        message(paste0("      Not enough neighbors for UMAP in '", current_cancer_type, "'. Skipping UMAP plot."))
      }
    } # End PCA/t-SNE/UMAP block
    
    # --- Heatmap with refined clusters ---
    message(paste0("    Generating Heatmap for '", current_cancer_type, "' (Refined clusters)..."))
    
    if (ncol(cancer_type_methylation_matrix) < 2) {
      message(paste0("      Not enough samples (", ncol(cancer_type_methylation_matrix), ") for heatmap for '", current_cancer_type, "'. Skipping heatmap."))
    } else {
      cancer_type_annotation_df_heatmap <- cancer_type_annotation_df %>%
        tibble::rownames_to_column("sample_id") %>%
        dplyr::arrange(refined_meth_cluster, sample_id) %>%
        tibble::column_to_rownames("sample_id")
      
      cancer_type_methylation_matrix_ordered <- cancer_type_methylation_matrix[, rownames(cancer_type_annotation_df_heatmap), drop = FALSE]
      
      matrix_values <- as.vector(as.matrix(cancer_type_methylation_matrix_ordered))
      matrix_values <- matrix_values[!is.na(matrix_values) & is.finite(matrix_values)]
      
      if (length(matrix_values) == 0) {
        message(paste0("      No finite methylation values for heatmap for '", current_cancer_type, "'. Skipping heatmap."))
      } else {
        min_val <- min(matrix_values)
        max_val <- max(matrix_values)
        color_breaks <- if (min_val == max_val) {
          c(min_val - 0.1, min_val + 0.1)
        } else {
          seq(0, 1, length.out = 100)
        }
        heatmap_colors <- colorRampPalette(c("blue", "white", "red"))(length(color_breaks))
        
        ordered_groups <- cancer_type_annotation_df_heatmap[rownames(cancer_type_annotation_df_heatmap), "refined_meth_cluster"]
        group_change_indices <- which(diff(as.numeric(factor(ordered_groups))) != 0)
        
        tryCatch({
          tiff(file.path(cancer_type_output_dir, paste0("Heatmap_", short_filename_id, "_refined.tiff")), width = 12, height = 10, units = "in", res = 300, compression = "lzw")
          pheatmap::pheatmap(
            cancer_type_methylation_matrix_ordered,
            cluster_rows = TRUE,
            cluster_cols = FALSE,
            show_colnames = FALSE,
            show_rownames = FALSE,
            annotation_col = cancer_type_annotation_df_heatmap,
            annotation_colors = current_plot_annotation_colors,
            main = paste0(current_cancer_type, ": Methylation Heatmap (Refined Clusters)"),
            color = heatmap_colors,
            breaks = color_breaks,
            fontsize = 10,
            border_color = NA
          )
          dev.off()
          message(paste0("      Saved heatmap with refined clusters for '", current_cancer_type, "'."))
        }, error = function(e) {
          message(paste0("      Failed to generate heatmap for '", current_cancer_type, "': ", e$message))
        })
      }
    }
    
    # --- Identificar CpGs top variables por diferencia estadística (modificado con control de tipo numérico) ---
    message(paste0("    Identifying top variable CpGs by Wilcoxon test for '", current_cancer_type, "'..."))
    
    # Identificar índices de muestras con estado methylated o unmethylated
    meth_indices <- which(cancer_type_annotation_df$Methylation_Profile_Group %in% grep("_Methylated$", unique(cancer_type_annotation_df$Methylation_Profile_Group), value = TRUE))
    unmeth_indices <- which(cancer_type_annotation_df$Methylation_Profile_Group %in% grep("_Unmethylated$", unique(cancer_type_annotation_df$Methylation_Profile_Group), value = TRUE))
    
    # Preparar dataframe para guardar resultados
    cpg_results <- data.frame(
      cpg = rownames(cancer_type_methylation_matrix),
      p_value = NA_real_,
      mean_meth = NA_real_,
      mean_unmeth = NA_real_,
      mean_diff = NA_real_
    )
    
    for (i in seq_len(nrow(cancer_type_methylation_matrix))) {
      vals <- cancer_type_methylation_matrix[i, ]
      
      # Forzar a numérico
      vals <- as.numeric(vals)
      
      vals_meth <- vals[meth_indices]
      vals_unmeth <- vals[unmeth_indices]
      
      vals_meth <- as.numeric(vals_meth)
      vals_unmeth <- as.numeric(vals_unmeth)
      
      # Test only if enough samples and not all NA
      if (length(vals_meth) > 1 && length(vals_unmeth) > 1 &&
          !all(is.na(vals_meth)) && !all(is.na(vals_unmeth))) {
        test <- wilcox.test(vals_meth, vals_unmeth)
        cpg_results$p_value[i] <- test$p.value
        cpg_results$mean_meth[i] <- mean(vals_meth, na.rm = TRUE)
        cpg_results$mean_unmeth[i] <- mean(vals_unmeth, na.rm = TRUE)
        cpg_results$mean_diff[i] <- abs(cpg_results$mean_meth[i] - cpg_results$mean_unmeth[i])
      }
    }
    
    # Ordenar por p-valor y diferencia
    cpg_results <- cpg_results %>%
      dplyr::arrange(p_value, desc(mean_diff))
    
    # Guardar resultados en archivo csv
    write.csv(cpg_results, file = file.path(cancer_type_output_dir, paste0("Top_CpGs_", short_filename_id, "_Wilcoxon.csv")), row.names = FALSE)
    message(paste0("      Saved top CpGs Wilcoxon results for '", current_cancer_type, "'."))
  }
}

print(validation_output_dir)




###########################################################################
############## 7. Predictive Modeling of Drug Response ####################
###########################################################################

message("\n--- Section 7: Starting Predictive Modeling of Drug Response ---")

# This section uses 'Methylation_Profile_Group' for eligibility.

prediction_output_dir <- file.path(output_dir, "Drug_Prediction_Models")
if (!dir.exists(prediction_output_dir)) {
  dir.create(prediction_output_dir, recursive = TRUE)
  message(paste0("Created Prediction Models directory: ", prediction_output_dir))
}

# Identify drug columns (using the convention 'drug_XXX')
# This assumes final_merged_data contains drug columns from the merge in new Section 3
drug_cols <- colnames(final_merged_data)[grepl("^drug_", colnames(final_merged_data))]

if (length(drug_cols) == 0) {
  message("No drug columns starting with 'drug_' found in final_merged_data. Skipping this analysis.")
} else {
  message(paste0("Found ", length(drug_cols), " drug columns for predictive modeling."))
  
  # Determine eligible cancer types for predictive modeling:
  # Need at least 3 samples in at least two Methylation_Profile_Groups for a cancer type
  message("Identifying eligible cancer types for predictive modeling based on Methylation Profile Groups...")
  pred_model_eligible_cancer_types <- final_merged_data %>% # final_merged_data contains cancer_type_fullname and Methylation_Profile_Group
    dplyr::group_by(cancer_type_fullname, Methylation_Profile_Group) %>%
    dplyr::summarise(n_samples = n(), .groups = 'drop') %>%
    dplyr::group_by(cancer_type_fullname) %>%
    dplyr::filter(n() >= 2 & all(n_samples >= 3)) %>% # At least 2 groups, each with >=3 samples
    dplyr::pull(cancer_type_fullname) %>% unique()
  
  if (length(pred_model_eligible_cancer_types) == 0) {
    message("No cancer types found with at least 3 samples in at least two methylation profile groups for predictive modeling. Skipping this section.")
  } else {
    message(paste0("Found ", length(pred_model_eligible_cancer_types), " cancer types eligible for predictive modeling."))
    
    all_model_performance <- list()
    
    # Prepare RNA-seq and Methylation data for global feature selection (for prediction)
    message("\nPreparing molecular feature data (RNA-seq and Methylation) for predictive modeling...")
    
    # Pivot RNA-seq data to wide format (samples as rows, genes as columns)
    # IMPORTANT: Use the global 'rnaseq_data' object directly here
    rnaseq_wide_all <- rnaseq_data %>% # Use the global long RNA-seq data object
      dplyr::select(sample, geneid, expression_value) %>%
      tidyr::pivot_wider(names_from = geneid, values_from = expression_value) %>%
      tibble::column_to_rownames("sample")
    
    # Select top N highly variable RNA-seq features (e.g., based on MAD)
    rnaseq_mad <- apply(rnaseq_wide_all, 2, mad, na.rm = TRUE)
    rnaseq_mad <- rnaseq_mad[!is.na(rnaseq_mad) & rnaseq_mad > 0] # Remove NAs and constant features
    top_n_genes <- min(5000, length(rnaseq_mad)) # Select top 5000 or fewer if less are variable
    top_rnaseq_features <- names(sort(rnaseq_mad, decreasing = TRUE))[1:top_n_genes]
    rnaseq_features_df_global <- rnaseq_wide_all %>%
      dplyr::select(all_of(top_rnaseq_features)) %>%
      tibble::rownames_to_column("sample")
    message(paste0("  Selected ", ncol(rnaseq_features_df_global) -1, " highly variable RNA-seq features (global)."))
    rm(rnaseq_wide_all, rnaseq_mad)
    
    # Methylation Data Feature Selection (for prediction) - using full methylation_data_wide from Section 1
    message("  Selecting highly variable Methylation features for predictive modeling (global)...")
    
    # Filter out non-numeric columns and then CpGs with too many NAs
    methylation_wide_for_pred_raw <- methylation_data_wide %>%
      tibble::column_to_rownames("sample") %>%
      dplyr::select_if(is.numeric) %>%
      dplyr::select(where(~ sum(is.na(.)) / length(.) < 0.2)) # Keep CpGs with <20% NAs
    
    methylation_mad_pred <- apply(methylation_wide_for_pred_raw, 2, mad, na.rm = TRUE)
    methylation_mad_pred <- methylation_mad_pred[!is.na(methylation_mad_pred) & methylation_mad_pred > 0]
    
    top_n_cpgs_pred <- min(5000, length(methylation_mad_pred))
    top_methylation_features <- names(sort(methylation_mad_pred, decreasing = TRUE))[1:top_n_cpgs_pred]
    
    methylation_features_df_global <- methylation_wide_for_pred_raw %>%
      dplyr::select(all_of(top_methylation_features)) %>%
      tibble::rownames_to_column("sample")
    
    message(paste0("  Selected ", ncol(methylation_features_df_global) -1, " highly variable Methylation features (global)."))
    rm(methylation_wide_for_pred_raw, methylation_mad_pred)
    gc()
    
    # Save global feature lists for prediction
    saveRDS(top_rnaseq_features, file.path(prediction_output_dir, "top_rnaseq_features_for_prediction.rds"))
    saveRDS(top_methylation_features, file.path(prediction_output_dir, "top_methylation_features_for_prediction.rds"))
    message(paste0("Saved top RNA-seq features to: ", file.path(prediction_output_dir, "top_rnaseq_features_for_prediction.rds")))
    message(paste0("Saved top Methylation features to: ", file.path(prediction_output_dir, "top_methylation_features_for_prediction.rds")))
    
    
    # Loop through each eligible cancer type for prediction modeling
    for (current_cancer_type in pred_model_eligible_cancer_types) {
      message(paste0("\n--- Building predictive models for: ", current_cancer_type, " ---"))
      
      # Filter final_merged_data for current cancer type to get sample IDs and drug responses
      current_cancer_type_drug_data <- final_merged_data %>%
        dplyr::filter(cancer_type_fullname == current_cancer_type) %>%
        dplyr::select(sample, Methylation_Profile_Group, all_of(drug_cols)) %>%
        drop_na(Methylation_Profile_Group) # Ensure group is available
      
      # Re-check group counts for this specific cancer type (as per DE eligibility logic)
      group_counts_pred_model <- current_cancer_type_drug_data %>%
        dplyr::distinct(sample, Methylation_Profile_Group) %>%
        dplyr::count(Methylation_Profile_Group)
      
      if (nrow(group_counts_pred_model) < 2 || any(group_counts_pred_model$n < 3)) {
        message(paste0("  Skipping ", current_cancer_type, ": Insufficient samples in methylation profile groups for predictive modeling after specific cancer type filtering."))
        next
      }
      
      message("\n--- DEBUGGING: Inspecting clustered_samples_info_filtered ---")
      message(paste0("Dimensions of clustered_samples_info_filtered: ", nrow(clustered_samples_info_filtered), " rows, ", ncol(clustered_samples_info_filtered), " columns."))
      message("Column names of clustered_samples_info_filtered:")
      print(colnames(clustered_samples_info_filtered))
      if ("cancer_type_fullname" %in% colnames(clustered_samples_info_filtered)) {
        message("First 5 cancer_type_fullname values:")
        print(head(clustered_samples_info_filtered$cancer_type_fullname, 5))
        message("Number of unique cancer_type_fullname values: ")
        print(length(unique(clustered_samples_info_filtered$cancer_type_fullname)))
      } else {
        message("ERROR: 'cancer_type_fullname' column NOT FOUND in clustered_samples_info_filtered.")
      }
      message("--- END DEBUGGING: clustered_samples_info_filtered ---\n")
      # Prepare combined feature matrix (X) for this cancer type
      common_samples <- current_cancer_type_drug_data$sample
      
      current_rnaseq_features_filtered <- rnaseq_features_df_global %>%
        dplyr::filter(sample %in% common_samples) %>%
        tibble::column_to_rownames("sample")
      
      current_methylation_features_filtered <- methylation_features_df_global %>%
        dplyr::filter(sample %in% common_samples) %>%
        tibble::column_to_rownames("sample")
      
      common_feature_samples_final <- intersect(
        rownames(current_rnaseq_features_filtered),
        rownames(current_methylation_features_filtered)
      )
      
      if (length(common_feature_samples_final) == 0) {
        message(paste0("  Skipping ", current_cancer_type, ": No common samples with both RNA-seq and Methylation data."))
        next
      }
      
      X_features <- current_rnaseq_features_filtered[common_feature_samples_final, ] %>%
        cbind(current_methylation_features_filtered[common_feature_samples_final, ])
      
      # Impute NAs in X_features with column median before modeling
      message("  Imputing NAs in combined X_features with column median...")
      for(col_name in colnames(X_features)){
        if(any(is.na(X_features[[col_name]]))){
          X_features[[col_name]][is.na(X_features[[col_name]])] <- median(X_features[[col_name]], na.rm = TRUE)
        }
      }
      
      # Ensure all features are numeric
      original_rownames_X_features <- rownames(X_features) # Store rownames
      X_features <- as.data.frame(lapply(X_features, as.numeric))
      rownames(X_features) <- original_rownames_X_features # Re-assign original rownames
      
      
      if (nrow(X_features) < 5) {
        message(paste0("  Skipping ", current_cancer_type, ": Less than 5 samples with complete feature data (N=", nrow(X_features), ")."))
        next
      }
      if (ncol(X_features) == 0) {
        message(paste0("  Skipping ", current_cancer_type, ": No molecular features available after filtering."))
        next
      }
      
      # Set up training control for caret (Elastic Net)
      fitControl <- caret::trainControl( # Explicitly use caret::trainControl
        method = "cv",
        number = 5,
        repeats = 1,
        savePredictions = "final",
        verboseIter = FALSE,
        allowParallel = TRUE # Use registered parallel backend
      )
      
      # Define the tuning grid for glmnet (Elastic Net)
      glmnetGrid <- expand.grid(alpha = seq(0.1, 1, by = 0.2),
                                lambda = exp(seq(-3, 2, length.out = 10)))
      
      model_performance_current_type <- tibble(
        Cancer_Type = current_cancer_type,
        Drug = character(),
        N_Samples_Modeled = integer(),
        Rsquared = numeric(),
        RMSE = numeric(),
        Optimal_Alpha = numeric(),
        Optimal_Lambda = numeric(),
        Top_Features_1 = character(),
        Top_Features_2 = character(),
        Top_Features_3 = character(),
        Top_Features_1_Annotation = character(), # New column for annotation
        Top_Features_2_Annotation = character(), # New column for annotation
        Top_Features_3_Annotation = character() # New column for annotation
      )
      
      # Loop through each drug for the current cancer type
      for (drug_col in drug_cols) {
        drug_name <- gsub("^drug_(.*)$", "\\1", drug_col)
        message(paste0("    Modeling drug: ", drug_name))
        
        # Prepare target variable (y) for this drug, aligning with X_features samples
        Y_response <- current_cancer_type_drug_data %>%
          dplyr::filter(sample %in% rownames(X_features)) %>%
          dplyr::arrange(match(sample, rownames(X_features))) %>% # Align order
          dplyr::pull(drug_col)
        
        # Remove samples where Y_response is NA
        valid_samples_idx <- !is.na(Y_response)
        if (sum(valid_samples_idx) < 5) { # Need at least 5 valid samples for modeling
          message(paste0("      Skipping ", drug_name, ": Insufficient valid drug response data (N=", sum(valid_samples_idx), ")."))
          next
        }
        
        X_model <- X_features[valid_samples_idx, ]
        Y_model <- Y_response[valid_samples_idx]
        
        tryCatch({
          # Train the Elastic Net model
          model_fit <- caret::train( # Explicitly use caret::train
            x = as.matrix(X_model),
            y = Y_model,
            method = "glmnet",
            tuneGrid = glmnetGrid,
            trControl = fitControl,
            metric = "Rsquared"
          )
          
          # --- START: Enhanced Filename Sanitization ---
          # Sanitize drug name for filename
          filename_safe_drug <- gsub("[^A-Za-z0-9_.]", "_", drug_name)
          filename_safe_drug <- gsub("[._]{2,}", "_", filename_safe_drug)
          filename_safe_drug <- gsub("^_|_$", "", filename_safe_drug) # Trim leading/trailing
          
          # Sanitize cancer type name for filename (same as Section 6.5)
          filename_safe_cancer_type <- gsub("[^A-Za-z0-9_.]", "_", current_cancer_type)
          filename_safe_cancer_type <- gsub("[._]{2,}", "_", filename_safe_cancer_type)
          filename_safe_cancer_type <- gsub("^_|_$", "", filename_safe_cancer_type) # Trim leading/trailing
          # --- END: Enhanced Filename Sanitization ---
          
          
          # Save the trained model
          model_save_dir <- file.path(prediction_output_dir, "Saved_Models")
          if (!dir.exists(model_save_dir)) {
            dir.create(model_save_dir, recursive = TRUE)
          }
          
          model_filename <- paste0("model_", filename_safe_cancer_type, "_", filename_safe_drug, ".rds")
          saveRDS(model_fit, file.path(model_save_dir, model_filename))
          message(paste0("        Model saved to: ", file.path(model_save_dir, model_filename)))
          
          # --- START: Added Outputs ---
          # Save Variable Importance
          var_imp <- caret::varImp(model_fit, scale = FALSE)$importance # Do not scale for direct coefficient interpretation
          if (!is.null(var_imp) && nrow(var_imp) > 0) {
            # Convert var_imp to a tibble and clean names for saving
            var_imp_df <- var_imp %>%
              tibble::rownames_to_column("Feature") %>%
              as_tibble() %>%
              arrange(desc(Overall)) # Assuming 'Overall' is the importance metric
            
            var_imp_filename <- paste0("VarImp_", filename_safe_cancer_type, "_", filename_safe_drug, ".csv")
            write_csv(var_imp_df, file.path(model_save_dir, var_imp_filename))
            message(paste0("        Variable importance saved to: ", file.path(model_save_dir, var_imp_filename)))
          }
          
          # Save Prediction Results (Actual vs. Predicted from cross-validation)
          if (!is.null(model_fit$pred) && nrow(model_fit$pred) > 0) {
            predictions_df <- model_fit$pred %>%
              as_tibble() %>%
              # Rename columns for clarity, e.g., actual vs. predicted drug response
              rename(Predicted_Response = pred, Actual_Response = obs) %>%
              dplyr::select(sample, Predicted_Response, Actual_Response, Resample) # Select relevant columns
            
            predictions_filename <- paste0("Predictions_", filename_safe_cancer_type, "_", filename_safe_drug, ".csv")
            write_csv(predictions_df, file.path(model_save_dir, predictions_filename))
            message(paste0("        Predictions saved to: ", file.path(model_save_dir, predictions_filename)))
          }
          # --- END: Added Outputs ---
          
          # Get best performance
          best_tune <- model_fit$bestTune
          best_results <- model_fit$results %>%
            dplyr::filter(alpha == best_tune$alpha, lambda == best_tune$lambda)
          
          # Extract top features (coefficients) from the best model
          coefs <- coef(model_fit$finalModel, s = best_tune$lambda)
          coefs_df <- as.data.frame(as.matrix(coefs))
          coefs_df$feature <- rownames(coefs_df)
          colnames(coefs_df)[1] <- "coefficient"
          
          top_coefs <- coefs_df %>%
            dplyr::filter(feature != "(Intercept)", coefficient != 0) %>%
            dplyr::arrange(desc(abs(coefficient))) %>%
            head(3)
          
          # NEW: Annotate top features
          top_features_annotated <- top_coefs %>%
            rowwise() %>%
            mutate(
              annotation = if_else(
                str_detect(feature, "^cg"), # Check if it's a CpG probe
                # If CpG, try to get gene/island info from epic_anno
                paste(epic_anno %>%
                        filter(probe == feature) %>%
                        dplyr::select(UCSC_RefGene_Name, Relation_to_Island) %>%
                        distinct() %>% # Ensure unique if probe maps to multiple entries
                        # Concatenate and handle potential NAs in annotation fields for display
                        # Use apply to handle multiple columns with paste
                        apply(., 1, function(row) paste(na.omit(row), collapse = " | ")),
                      collapse = " ; "), # If a CpG maps to multiple genes/islands
                # Else (it's a geneid), try to get gene symbol
                gene_symbol_map_df %>%
                  filter(geneid == feature) %>%
                  pull(gene) %>%
                  paste(collapse = " ; "), # If a geneid maps to multiple symbols (rare, but robust)
                NA_character_
              )
            ) %>%
            ungroup() %>%
            mutate(
              annotation = case_when(
                str_detect(feature, "^cg") & is.na(annotation) ~ "CpG (No Gene/Island Info)",
                str_detect(feature, "^cg") & !is.na(annotation) & nchar(annotation) > 0 ~ paste0("CpG (", annotation, ")"),
                !str_detect(feature, "^cg") & !is.na(annotation) & nchar(annotation) > 0 ~ paste0("Gene (", annotation, ")"),
                TRUE ~ "Unknown Feature Type" # Fallback for unannotated or unexpected features
              )
            )
          
          
          model_performance_current_type <- model_performance_current_type %>%
            add_row(
              Cancer_Type = current_cancer_type,
              Drug = drug_name,
              N_Samples_Modeled = nrow(X_model),
              Rsquared = best_results$Rsquared,
              RMSE = best_results$RMSE,
              Optimal_Alpha = best_tune$alpha,
              Optimal_Lambda = best_tune$lambda,
              Top_Features_1 = ifelse(nrow(top_coefs) >= 1, top_coefs$feature[1], NA_character_),
              Top_Features_2 = ifelse(nrow(top_coefs) >= 2, top_coefs$feature[2], NA_character_),
              Top_Features_3 = ifelse(nrow(top_coefs) >= 3, top_coefs$feature[3], NA_character_),
              Top_Features_1_Annotation = ifelse(nrow(top_features_annotated) >= 1, top_features_annotated$annotation[1], NA_character_),
              Top_Features_2_Annotation = ifelse(nrow(top_features_annotated) >= 2, top_features_annotated$annotation[2], NA_character_),
              Top_Features_3_Annotation = ifelse(nrow(top_features_annotated) >= 3, top_features_annotated$annotation[3], NA_character_)
            )
          
        }, error = function(e) {
          message(paste0("      Error modeling ", drug_name, " in ", current_cancer_type, ": ", e$message))
        })
      } # End of drug loop
      
      if (nrow(model_performance_current_type) > 0) {
        # Use the newly sanitized cancer type name for this summary file
        filename_safe_cancer_type_for_perf <- gsub("[^A-Za-z0-9_.]", "_", current_cancer_type)
        filename_safe_cancer_type_for_perf <- gsub("[._]{2,}", "_", filename_safe_cancer_type_for_perf)
        filename_safe_cancer_type_for_perf <- gsub("^_|_$", "", filename_safe_cancer_type_for_perf)
        perf_filename <- paste0("Drug_Prediction_Performance_", filename_safe_cancer_type_for_perf, ".csv")
        write_csv(model_performance_current_type, file.path(prediction_output_dir, perf_filename))
        message(paste0("  Model performance saved to: ", file.path(prediction_output_dir, perf_filename)))
        
        all_model_performance[[current_cancer_type]] <- model_performance_current_type
      } else {
        message(paste0("  No successful models built for ", current_cancer_type, "."))
      }
      rm(current_cancer_type_drug_data, X_features)
      gc()
    } # End of cancer type loop
    
    if (length(all_model_performance) > 0) {
      combined_model_performance <- bind_rows(all_model_performance)
      message("\n--- Summary of All Drug Prediction Model Performance ---")
      print(combined_model_performance %>%
              dplyr::arrange(desc(Rsquared)) %>%
              head(10))
      
      write_csv(combined_model_performance, file.path(output_dir, "Combined_Drug_Prediction_Performance.csv"))
      message(paste0("Combined model performance saved to: ", file.path(output_dir, "Combined_Drug_Prediction_Performance.csv")))
    } else {
      message("\nNo successful prediction models built across any eligible cancer type.")
    }
  }
}

# IMPORTANT NOTE:
# The following lines `stopCluster(cl)` and `registerDoSEQ()` assume that
# `cl` (your parallel cluster object) was created and registered earlier in your script.
# Ensure that these lines are appropriate for your overall script's parallel setup.
# If 'cl' is not defined or is not a cluster object, these lines might cause an error.
# Remove or comment out these lines if you are NOT using parallel processing.
stopCluster(cl)
registerDoSEQ() # Register sequential backend again
message("\n--- Predictive Modeling of Drug Response Complete ---")
message("\n--- Script Finished ---")
